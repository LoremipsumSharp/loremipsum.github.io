[{"title":"AspNetCore2.1升级到3.1时CORS相关配置的变更","url":"/2020/02/19/AspNetCore2.1升级到3.1时CORS相关配置的变更/","content":"\n本周将公司的运营系统从AspNetCore2.1升级到了AspNetCore3.1,遇到了一些坑，这里记录以下\n\n## 2.1的相关CORS代码\n\n\n```\npublic IServiceProvider ConfigureServices(IServiceCollection services)\n{\n\n        ... // 省略\n        services.AddCors(option => option.AddPolicy(\"corsPolicy\", builders =>\n        {\n            builders.AllowCredentials().AllowAnyOrigin().AllowAnyHeader().AllowAnyMethod();\n        }));\n        ... // 省略\n}\n\npublic void Configure(IApplicationBuilder app, ILoggerFactory loggerFactory, IHostingEnvironment env)\n{\n    ... // 省略\n    app.UseCors(\"corsPolicy\");\n     ... // 省略\n}\n```\n\n如果这部分代码这3.1的服务中不加任何修改，启动时提示错误：\n\n\n```\nThe CORS protocol does not allow specifying a wildcard (any) origin and credentials at the same time. Configure the CORS policy by listing individual origins if credentials needs to be supported.\n```\n\n\n这是由于在2.1之后,AspNetCore出于安全考虑，做了更加严格的限制，在不AllowCredentials()与AllowAnyOrigin()。\n\n假设现在站点A存在一个恶意脚本，而站点B存在一个比较的敏感的接口（如转账）。如果站点B作为服务端使用AllowCredentials()与AllowAnyOrigin()的同源配置，此时站点A可以直接调用站点B的敏感接口并发送凭证信息（如Cookie），那么将导致用户信息被窃取。\n\n\n\n## 3.1的相关CORS代码\n\n### options1 显示声明允许跨域的origin\n\n```\nservices.AddCors(option => option.AddPolicy(\"corsPolicy\", builders =>\n            {\n                builders.WithOrigins(\"http://site.com\").AllowAnyHeader().AllowAnyMethod().AllowCredentials();\n            }));\n```\n\n\n### options2 使用 SetIsOriginAllowed（可以起到与AllowAnyOriginu一样的效果）\n\n\n```\nservices.AddCors(option => option.AddPolicy(\"corsPolicy\", builders =>\n            {\n                builders.SetIsOriginAllowed(origin=>true).AllowAnyHeader().AllowAnyMethod().AllowCredentials(); //SetIsOriginAllowed(origin=>true)允许所有origin\n            }));\n```\n\n\n"},{"title":"Maven库配置阿里云加速","url":"/2020/02/17/Maven库配置阿里云加速/","content":"\n由于国内的网络原因,通过maven拉取相关package的时候总是特别慢，极大的影响到工作效率。所幸的是阿里云提供了maven库的镜像服务，体验了一下，速度飞快。配置方法如下：\n\n## Maven仓库配置阿里云加速\n- 确定settings.xml配置文件位置\n执行如下命令：\n\n```\nmvn -X\n```\n\n输入如下：\n\n```\n.....省略\n[DEBUG] Reading global settings from /usr/share/maven/conf/settings.xml\n[DEBUG] Reading user settings from /home/abc/.m2/settings.xml\n[DEBUG] Reading global toolchains from /usr/share/maven/conf/toolchains.xml\n[DEBUG] Reading user toolchains from /home/loremipsum/.m2/toolchains.xml\n[DEBUG] Using local repository at /home/abc/.m2/repository\n\n.....省略\n```\n\n- 修改settings.xml,修改mirrors xml结点下的相关配置\n\n```\n  <mirrors>\n    <!-- mirror\n     | Specifies a repository mirror site to use instead of a given repository. The repository that\n     | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used\n     | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.\n     |\n    <mirror>\n      <id>mirrorId</id>\n      <mirrorOf>repositoryId</mirrorOf>\n      <name>Human Readable Name for this Mirror.</name>\n      <url>http://my.repository.com/repo/path</url>\n    </mirror>\n     -->\n    <mirror>\n      <id>aliyun-public</id>\n      <name>aliyun public</name>\n      <mirrorOf>public</mirrorOf>\n      <url>https://maven.aliyun.com/repository/public</url>\n    </mirror>\n\n    <mirror>\n      <id>aliyun-central</id>\n      <name>aliyun central</name>\n      <mirrorOf>central</mirrorOf>\n      <url>https://maven.aliyun.com/repository/central</url>\n    </mirror>\n\n    <mirror>\n      <id>aliyun-jcenter</id>\n      <name>aliyun jcenter</name>\n      <mirrorOf>jcenter</mirrorOf>\n      <url>https://maven.aliyun.com/repository/jcenter</url>\n    </mirror>\n\n    <mirror>\n      <id>aliyun-spring</id>\n      <name>aliyun spring</name>\n      <mirrorOf>spring</mirrorOf>\n      <url>https://maven.aliyun.com/repository/spring</url>\n    </mirror>\n\n    <mirror>\n      <id>aliyun-spring-milestones</id>\n      <name>aliyun spring milestones</name>\n      <mirrorOf>spring-milestones</mirrorOf>\n      <url>https://maven.aliyun.com/repository/spring</url>\n    </mirror>\n\n    <mirror>\n      <id>aliyun-spring-plugin</id>\n      <name>aliyun spring plugin</name>\n      <mirrorOf>spring-plugin</mirrorOf>\n      <url>https://maven.aliyun.com/repository/spring-plugin</url>\n    </mirror>\n\n    <mirror>\n      <id>aliyun-gradle-plugin</id>\n      <name>aliyun gradle plugin</name>\n      <mirrorOf>gradle-plugin</mirrorOf>\n      <url>https://maven.aliyun.com/repository/gradle-plugin</url>\n    </mirror>\n\n    <mirror>\n      <id>aliyun-google</id>\n      <name>aliyun google</name>\n      <mirrorOf>google</mirrorOf>\n      <url>https://maven.aliyun.com/repository/google</url>\n    </mirror>\n\n    <mirror>\n      <id>aliyun-grails-core</id>\n      <name>aliyun grails core</name>\n      <mirrorOf>grails-core</mirrorOf>\n      <url>https://maven.aliyun.com/repository/grails-core</url>\n    </mirror>\n</mirrors>\n\n```\n\n## 防坑：\n大部分的包阿里云的maven镜像库都有，一部分比较新的库上面是没有的，如springboot，阿里云上面的版本只是到了2.2.0，实际2.2.4都已经出来了，同步不是很及时。目前我都一些没有的库做了降级处理，后续再看看怎么处理这个问题\n"},{"title":"InnodDB中的Gap Locks与Next-key Locks","url":"/2020/02/17/InnodDB中的Gap Locks与Next-key Locks/","content":"\n为了理解Gap Locks与Next-key Locks首先必须了解InnodDB定义的四种隔离级别\n\n## InnodDB的四种隔离级别\n\n1. Read uncommitted(未授权读取、读未提交)：如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。这样就避免了更新丢失，却可能出现脏读。也就是说事务B读取到了事务A未提交的数据。\n2. Read committed（授权读取、读提交）： 读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。该隔离级别避免了脏读，但是却可能出现不可重复读。事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。\n3. Repeatable read（可重复读取,MySQL默认隔离级别）： 可重复读是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，即使第二个事务对数据进行修改，第一个事务两次读到的的数据是一样的。这样就发生了在一个事务内两次读到的数据是一样的，因此称为是可重复读。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。这样避免了不可重复读取和脏读，但是有时可能出现幻象读。（读取数据的事务）这可以通过“共享读锁”和“排他写锁”实现。\n4. Serializable（序列化）： 提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。序列化是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。 \n\n\n## Gap Locks\n如下图所示：假设存在一个索引(Key,pk),那么当innodb在一事务中中对(-∞,(9,5)]追加Gap Locks后,如果其他事务尝试在索引记录中的任意一个Gap添加记录,该事务将会被阻塞\n![](https://raw.githubusercontent.com/LoremipsumSharp/Images/master/img/WeChat%20Screenshot_20200217021548.png)\n\n## Next-key Locks\nNext-key Locks = Gap Locks + index-record lock。\n当在某一个事务中执行一个SELECT语句，Innodb会通过扫描相应的索引记录来找到生成一个ResultSet，这个时候被扫描到的索引记录都被被添加Next-key locks。\n举个例子，假设现在存在一张表T，T的主键为ID，ID的可能值是10，11，13，20。\n现在在一个事务中执行如下语句：\n\n```\nSELECT ID FROM T WHERE ID >=10 AND ID <= 20 FOR UPDATE;\n```\n\n这个时候会产生的Next-key Locks如下:\n\n```\n(-∞, 10]\n(10, 11]\n(11, 13]\n(13, 20]\n(20, +∞)\n```\n其他事务不能这个范围内将不能插入新的纪录（避免了幻读），也不能修改相应的记录（避免了不可重复读）\n\n可见Next-key Locks与Gap Locks主要是为了满足Repeatable read的一致性要求。\n\n另外值得注意的一点是，如果被扫描到的索引是一个唯一索引，且只有并且只有一笔记录，那么这个时候只会上index-record lock，因为这个时候其他事务产生了新的记录，也不会产生幻读。\n\n\n\n\n\n\n"},{"title":"Hello World","url":"/2020/02/16/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]