<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Loremipsum Blog</title>
  <icon>https://www.gravatar.com/avatar/bcce300a816652e13f1514ef10ae2d8a</icon>
  <subtitle>Things always get worse before they get better.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://loremipsumsharp.github.io/"/>
  <updated>2023-01-28T19:05:10.373Z</updated>
  <id>https://loremipsumsharp.github.io/</id>
  
  <author>
    <name>Loremipsum</name>
    <email>mvclogic@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Prometheus计算P99的原理</title>
    <link href="https://loremipsumsharp.github.io/2023/01/28/Prometheus%E8%AE%A1%E7%AE%97P99%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>https://loremipsumsharp.github.io/2023/01/28/Prometheus%E8%AE%A1%E7%AE%97P99%E7%9A%84%E5%8E%9F%E7%90%86/</id>
    <published>2023-01-27T18:11:00.000Z</published>
    <updated>2023-01-28T19:05:10.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>近期在对Kong网关的Service超时参数进行调整，通过配置合理的Timeout可以让Kong网关在当upstream出现异常时熔断，及时的回收对应的TCP链接，避免因为积压大量TCP连接导致整个服务异常（如端口数被占满）</p><p>为了给upstream配置一个合理的Timeout参数，我们需要调取监控数据，通过监控数据来评估整个服务的整体延迟状况，这里有一个关键指标<code>P99</code></p><p>何谓P99：<br><code>在所有采集到的样本中，如果存在一个值满足整个样本空间中99%的数据都小于该值，那么该值我们称之为这个样本空间的P99</code></p><p>显然，只要我们计算出P99，那么这个P99就可以作为Kong Service的Timeout参数</p><p>目前我们在监控端使用的是Prometheus，所以我们可以利用Prometheus的内置函数<code>histogram_quantile</code>得到一个metric的P99，那么<code>histogram_quantile</code>的工作原理是怎么样的？下面简单介绍一下</p><h2 id="histogram-quantile的工作原理"><a href="#histogram-quantile的工作原理" class="headerlink" title="histogram_quantile的工作原理"></a>histogram_quantile的工作原理</h2><p>首先，根据文档我们知道<code>histogram_quantile(φ float, b instant-vector)</code>接收两个参数，第一个参数φ指的是分位点，当我们计算P99的时候，这个分位点就是0.99。第二个参数是一个histogram bucket类型的向量b</p><p>根据我们之前提到过P99的定义，假设我有1000个样本，那么我从大到小找出排第990名的值，这个值就是这个样本空间的P99，以此类推如果样本空间的数量为N，<code>histogram_quantile(φ float, b instant-vector)</code>实际上是帮我们找到这排名第0.99N的那个指标值（这个值是一个估算值，并不是真的去找排名第0.99N）</p><p>我们知道<code>histogram_quantile(φ float, b instant-vector)</code>的第二个参数是一个关于histogram bucket类型的向量b，通常对于每一个histogram metric，我们都会定义若干个bucket，每一个bucket代表一个区间的范围，比如我想在想监控服务各个接口的整体延时情况，那么我会定义一个<code>histogram</code>指标<code>server_latency_milliseconds</code>,对于<code>server_latency_milliseconds</code>我会为他分配5个bucket：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;100ms,&lt;500ms,&lt;1000ms,&lt;3000ms,&lt;+INFms</span><br></pre></td></tr></table></figure><p>这5个bucket也对应了5个不同的<code>counter</code>指标<br>如果一个请求响应时间为600ms，那么它就会落到这三个bucket&lt;1000ms,&lt;3000ms,&lt;+INFms</p><p>回到正题，Prometheus是如何利用这5个bucket counter来计算P99的，<br>我们注意到这5个bucket</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;100ms,&lt;500ms,&lt;1000ms,&lt;3000ms,&lt;+INFms</span><br></pre></td></tr></table></figure><p>实际上是可以转化为以下区间段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0,100ms),[100ms,500ms),[500ms,1000ms),[1000ms,3000ms),[3000ms,+INFms)</span><br></pre></td></tr></table></figure><p>对于一个给定的时间窗口t，可以通过<code>rate</code>函数计算出各个bucket的变化率，比如知道bucket 500ms的变化率，bucket 100ms的变化率，那么就可以知道在时间窗口t有多少样本是落入到[100ms,500ms)这个区间，以此类推，可以知道每个区间段的样本数，那么从大到小排列，就可以得出第0.99N样本是落入到哪个区间段。那么知道落入到哪个区间段后，我们该怎么估算P99的值？其实，Prometheus底层认为样本在各个区间段内是均匀分布的，所以如果如果某个区间段C共有S个样本，第0.99N样本在区间段C排名为K，那么有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P99&#x3D;（C的最大值-C的最小值）&#x2F;S * K</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="!https://zhuanlan.zhihu.com/p/104607739">Prometheus 常用函数 histogram_quantile 的若干“反直觉”问题</a><br><a href="!https://stackoverflow.com/questions/55162093/understanding-histogram-quantile-based-on-rate-in-prometheus">Understanding histogram_quantile based on rate in Prometheus</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;近期在对Kong网关的Service超时参数进行调整，通过配置合理的Timeout可以让Kong网关在当upstream出现异常时熔断，及时
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Kong路径匹配算法总结</title>
    <link href="https://loremipsumsharp.github.io/2022/08/21/Kong%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93/"/>
    <id>https://loremipsumsharp.github.io/2022/08/21/Kong%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-20T19:11:00.000Z</published>
    <updated>2022-08-20T19:34:51.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>目前Kong一共支持两种路由规则<code>v0</code>及<code>v1</code>，这里指的路由规则是说当Kong接受到一个http请求之后会如何生成最终的请求url，这里简单总结下这两种规则的匹配逻辑，根据需求，可以按需使用</p><h1 id="v0"><a href="#v0" class="headerlink" title="v0"></a>v0</h1><p>假设当前Kong有以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">服务s：s.path &#x3D; &#x2F;service </span><br><span class="line">路由r: r.path &#x3D; &#x2F;route</span><br><span class="line">       r.strip_path &#x3D; true</span><br><span class="line">上游u: u.target &#x3D; https:&#x2F;&#x2F;google.com</span><br></pre></td></tr></table></figure><p>如果当前请求url为<code>http://kong/route/foo</code>，当Kong接受到这个请求后首先可以判定这个请求命中了<code>路由r</code>，这个时候由于<code>路由r</code>有<code>router.strip_path = true</code>并且<code>路由r</code>对应的<code>服务s</code>有<code>service.path = /service</code>，那么最终生成的请求路径为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;google.com&#x2F;service&#x2F;foo</span><br></pre></td></tr></table></figure><p>如果<code>路由r</code>有<code>r.strip_path=false</code>，那么最终生成的请求路径为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;google.com&#x2F;service&#x2F;route&#x2F;foo</span><br></pre></td></tr></table></figure><blockquote><p>这里可以知道strip_path这个参数会影响到Kong是否会剥离路由定义的path</p></blockquote><h1 id="v1"><a href="#v1" class="headerlink" title="v1"></a>v1</h1><p>假设当前Kong有以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">服务s：s.path &#x3D; &#x2F;service </span><br><span class="line">路由r: r.path &#x3D; &#x2F;route</span><br><span class="line">       r.strip_path &#x3D; true</span><br><span class="line">上游u: u.target &#x3D; https:&#x2F;&#x2F;google.com</span><br></pre></td></tr></table></figure><p>如果当前请求url为<code>http://kong/route/foo</code>，当Kong接受到这个请求后首先可以判定这个请求命中了<code>路由r</code>，这个时候由于<code>路由r</code>有<code>router.strip_path = true</code>并且<code>路由r</code>对应的<code>服务s</code>有<code>service.path = /service</code>，那么最终生成的请求路径为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;google.com&#x2F;service&#x2F;foo</span><br></pre></td></tr></table></figure><blockquote><p>这里可以看出当router.strip_path = true时，v0和v1算法的表现是一样的</p></blockquote><p>如果<code>路由r</code>有<code>r.strip_path=false</code>，那么最终生成的请求路径为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;google.com&#x2F;serviceroute&#x2F;foo</span><br></pre></td></tr></table></figure><blockquote><p>这里可以知道strip_path=false时，和v0有所不同，这里strip_path实际上时会将route.path的斜杠去掉后再将service.path与route.path拼接到一起</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;目前Kong一共支持两种路由规则&lt;code&gt;v0&lt;/code&gt;及&lt;code&gt;v1&lt;/code&gt;，这里指的路由规则是说当Kong接受到一个ht
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Kong网关CPU问题排查</title>
    <link href="https://loremipsumsharp.github.io/2022/07/17/Kong%E7%BD%91%E5%85%B3%20CPU%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>https://loremipsumsharp.github.io/2022/07/17/Kong%E7%BD%91%E5%85%B3%20CPU%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</id>
    <published>2022-07-17T03:29:00.000Z</published>
    <updated>2022-07-24T17:18:04.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在Kong网关上线之前，公司原本是使用openresty作为所有业务的流量入口，qps 10w+，配置将近3000多条路由,其中大部分是正则路由。但是openresty的服务治理功能相对较弱，没有像Kong那样内置了大量开箱即用的插件，为了后续将一些服务治理的功能陆续迁移到网关层，如熔断，限流，决定使用Kong API网关对原有的Openresty进行替换，使用的版本是2.7.1</p><p>在Kong网关上线后，其在CPU使用率上的不能让人满意，对该问题进行了排查并对此进行了优化</p><h1 id="问题纪录"><a href="#问题纪录" class="headerlink" title="问题纪录"></a>问题纪录</h1><p>Kong网关上线后，我们逐步的将生产环境的流量从openresty切换到Kong，最开始，CPU负载表现正常，如下图所示：<br><img src="https://raw.githubusercontent.com/LoremipsumSharp/Images/master/img/before.png" alt="enter image description here">，每一个POD大概使用了0.4个核</p><p>当我们开始将一些请求量大的接口切换到Kong网关上时，CPU占用率激增，从0.4核增加到了1.5核，一些POD CPU占用率更是达到了2.5核<br><img src="https://raw.githubusercontent.com/LoremipsumSharp/Images/master/img/after.png" alt="enter image description here"> </p><p>为了解决CPU占用率过高的问题，首先我们使用火焰图找出当前Kong网关内部的一些调用热点：</p><p><img src="https://raw.githubusercontent.com/LoremipsumSharp/Images/master/img/max.svg" alt=""></p><p>从上图可以看出，整个Kong网关的CPU都消耗在了正则匹配上。</p><p>我们进一步排查发现，我们这些流量很大的接口实际上并没有用到正则表达式，而是一个简单的前缀匹配(开启strip_path)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;foo</span><br></pre></td></tr></table></figure><p>如上所示：当Kong拿到一个请求，如<code>http://bar.com/foo/xxxx</code>，那么这个时候Kong会将这个地址转化为<code>foo</code>对应的<code>upstream</code>,最终的URL为<code>http://foo-upstream/xxx</code>，进一步排查<code>Kong</code>源码，有如下发现，<br>当Kong初始化内部的路由表时，会将所有正则路由存放到一个<code>regex_uris</code>中，所有前缀匹配的路由存放到<code>prefix_uris</code>:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">index_route_t</span><span class="params">(route_t, plain_indexes, prefix_uris, regex_uris,</span></span></span><br><span class="line"><span class="function"><span class="params">                             wildcard_hosts, src_trust_funcs, dst_trust_funcs)</span></span></span><br><span class="line">   <span class="comment">-- 省略不重要的代码</span></span><br><span class="line">  <span class="keyword">for</span> _, uri_t <span class="keyword">in</span> <span class="built_in">ipairs</span>(route_t.uris) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> uri_t.is_prefix <span class="keyword">then</span></span><br><span class="line">      plain_indexes.uris[uri_t.value] = <span class="literal">true</span></span><br><span class="line">      <span class="built_in">insert</span>(prefix_uris, uri_t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">insert</span>(regex_uris, uri_t)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>当Kong收到一个请求的时候，需要判断这个请求是正则的路由还是前缀匹配的路由：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">find_route</span><span class="params">(req_method, req_uri, req_host, req_scheme,</span></span></span><br><span class="line"><span class="function"><span class="params">                          src_ip, src_port,</span></span></span><br><span class="line"><span class="function"><span class="params">                          dst_ip, dst_port,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"> <span class="comment">-- 这里只截取关键代码</span></span><br><span class="line">  <span class="comment">-- uri match</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">1</span>, #regex_uris <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> from, _, err = re_find(req_uri, regex_uris[i].regex, <span class="string">"ajo"</span>)</span><br><span class="line">    <span class="keyword">if</span> err <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">log</span>(ERR, <span class="string">"could not evaluate URI regex: "</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> from <span class="keyword">then</span></span><br><span class="line">      hits.uri     = regex_uris[i].value</span><br><span class="line">      req_category = bor(req_category, MATCH_RULES.URI)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> hits.uri <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> plain_indexes.uris[req_uri] <span class="keyword">then</span></span><br><span class="line">      hits.uri     = req_uri</span><br><span class="line">      req_category = bor(req_category, MATCH_RULES.URI)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">for</span> i = <span class="number">1</span>, #prefix_uris <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">find</span>(req_uri, prefix_uris[i].value, <span class="literal">nil</span>, <span class="literal">true</span>) == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">          hits.uri     = prefix_uris[i].value</span><br><span class="line">          req_category = bor(req_category, MATCH_RULES.URI)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如上所示，很明显当Kong收到一个请求后，首先遍历<code>regex_uris</code>看下当前请求能否被正则命中，如果不能则接着遍历<code>prefix_uris</code>，看下能否被前缀命中。</p><p>由于那些流量很大的接口我们都使用了前缀路由，也就是说在这种情况下去命中一条路由我们需要遍历整个<code>regex_uris</code> ，正则匹配消耗了大量的CPU，符合火焰图观测结果。那么问题来了，我们能不能将之部分流量大的路由在匹配过程中前置，而不是每次都让<code>Kong</code>去遍历整个路由表？很显然是可以的。<br>首先，我们可以将前缀路由转化为正则路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;foo -&gt; &#x2F;foo&#x2F;(\S+)</span><br></pre></td></tr></table></figure><p>其次，为了让这个路由能够在<code>regex_uris</code>的尽可能靠前的位置我们可以设置<code>Regex priority</code>,给他一个足够大的值，这样Kong在生成内部路由表的时候对于正则路由会按照<code>Regex priority</code>排序</p><p>按照上述思路对大流量的前缀路由进行调整，CPU过高的问题最终消失</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在Kong网关上线之前，公司原本是使用openresty作为所有业务的流量入口，qps 10w+，配置将近3000多条路由,其中大部分是正则
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>如何使用GORM访问MySQL bit类型</title>
    <link href="https://loremipsumsharp.github.io/2022/03/26/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8GORM%E8%AE%BF%E9%97%AEMySQL%20bit%E7%B1%BB%E5%9E%8B/"/>
    <id>https://loremipsumsharp.github.io/2022/03/26/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8GORM%E8%AE%BF%E9%97%AEMySQL%20bit%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-03-25T16:44:00.000Z</published>
    <updated>2022-03-25T16:55:40.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>使用<code>GORM</code>访问<code>MySQL</code>，提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:&#x2F;Development&#x2F;Go&#x2F;demohub&#x2F;playground&#x2F;gorm_test.go:111 sql: Scan error on column index 19, name &quot;Enabled&quot;: converting driver.Value type []uint8 (&quot;\x01&quot;) to a int64: invalid syntax</span><br><span class="line">[1.626ms] [rows:1] SELECT * FROM &#96;content&#96; WHERE &#96;id&#96; &#x3D; 546 LIMIT 1</span><br></pre></td></tr></table></figure><p>这里<code>GORM</code>无法将<code>MySQL</code>的<code>bit(1)</code>转化为<code>Golang</code>的<code>bool</code></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>给bool类型定义一个alias，<code>BitBool</code>,并实现<code>Scan</code>及<code>Value</code>接口，如下所示：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BitBool is an implementation of a bool for the MySQL type BIT(1).</span></span><br><span class="line"><span class="comment">// This type allows you to avoid wasting an entire byte for MySQL's boolean type TINYINT.</span></span><br><span class="line"><span class="keyword">type</span> BitBool <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Value implements the driver.Valuer interface,</span></span><br><span class="line"><span class="comment">// and turns the BitBool into a bitfield (BIT(1)) for MySQL storage.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b BitBool)</span> <span class="title">Value</span><span class="params">()</span> <span class="params">(driver.Value, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">byte</span>&#123;<span class="number">1</span>&#125;, <span class="literal">nil</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">byte</span>&#123;<span class="number">0</span>&#125;, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scan implements the sql.Scanner interface,</span></span><br><span class="line"><span class="comment">// and turns the bitfield incoming from MySQL into a BitBool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BitBool)</span> <span class="title">Scan</span><span class="params">(src <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    v, ok := src.([]<span class="keyword">byte</span>)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"bad []byte type assertion"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    *b = v[<span class="number">0</span>] == <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后需要将<code>strut</code>中的bool字段替换为<code>BitBool</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/47535543/mysqls-bit-type-maps-to-which-go-type" target="_blank" rel="noopener">MySQL’s bit type maps to which Go type</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;使用&lt;code&gt;GORM&lt;/code&gt;访问&lt;code&gt;MySQL&lt;/code&gt;，提示&lt;/p&gt;
&lt;figure class=&quot;highligh
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>使用IdentityModel.AspNetCore简化Token管理</title>
    <link href="https://loremipsumsharp.github.io/2022/02/28/%E4%BD%BF%E7%94%A8IdentityModel.AspNetCore%E7%AE%80%E5%8C%96Token%E7%AE%A1%E7%90%86/"/>
    <id>https://loremipsumsharp.github.io/2022/02/28/%E4%BD%BF%E7%94%A8IdentityModel.AspNetCore%E7%AE%80%E5%8C%96Token%E7%AE%A1%E7%90%86/</id>
    <published>2022-02-27T17:13:00.000Z</published>
    <updated>2022-02-27T18:48:08.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在日常开发过程中，我们常常需要通过<code>OAUTH2</code>去接入一些第三方站点，一般分为一下三个步骤:</p><ol><li>通过<code>ClientId</code>,<code>ClientSecret</code>调用第三方的<code>TokenEndpoint</code>获取<code>AccessToken</code></li><li>将步骤1得到的<code>AccessToken</code>进行缓存,避免重复获取<code>AccessToken</code>损耗应用性能</li><li>使用<code>AccessToken</code>调用第三方站点的<code>API</code></li></ol><p>针对上面提到的3个步骤，我们通常会在应用中定义一个<code>TokenStore</code>来管理Token,当<code>HttpClient</code>发起调用的时候，我们会从<code>TokenStore</code>获取已缓存的<code>AccessToken</code>后设置<code>Authorization</code>头，如果涉及到<code>RefreshToken</code>的场景，那么整个过程会更加复杂，那么目前有没有一些基于<code>OAUTH2</code>标准的<code>Token</code>管理库呢? 答案是:<code>IdentityModel.AspNetCore</code></p><h2 id="IdentityModel-AspNetCore"><a href="#IdentityModel-AspNetCore" class="headerlink" title="IdentityModel.AspNetCore"></a>IdentityModel.AspNetCore</h2><p><code>IdentityModel.AspNetCore</code>是<code>IdentityServer4</code>开发团队开源的一个<code>Token</code>管理库,通过<code>IdentityModel.AspNetCore</code>我们无需关心<code>Token</code>的生命周期,<code>IdentityModel.AspNetCore</code>会根据<code>Token</code>的类型及生命周期自动为对应的<code>HttpClient</code>设置<code>Token</code>,使用方法如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F;  添加外部服务clients</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;services&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;appSettingConfig&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;</span><br><span class="line">public static IServiceCollection AddServiceClients(this IServiceCollection services, AppSettingConfig appSettingConfig)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 添加AddAccessTokenManagement</span><br><span class="line">    &#x2F;&#x2F; 这里定一个与第三方idp通信的HttpClient</span><br><span class="line">    services.AddAccessTokenManagement(options &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        options.Client.Clients.Add(&quot;idp&quot;, new ClientCredentialsTokenRequest()</span><br><span class="line">        &#123;</span><br><span class="line">            Address &#x3D; PathUtils.UrlCombine(appSettingConfig.HttpClientConfig.HttpClientMembers.FirstOrDefault(x &#x3D;&gt; x.Name &#x3D;&#x3D; &quot;idp&quot;).BaseUrl, &quot;connect&#x2F;token&quot;),</span><br><span class="line">            ClientId &#x3D; appSettingConfig.JwtConfig.ClientId,</span><br><span class="line">            ClientSecret &#x3D; appSettingConfig.JwtConfig.ClientSecret,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; AddClientAccessTokenHandler的本质是一个DelegateHandler</span><br><span class="line">    &#x2F;&#x2F; 当HttpClient发起请求的时候会通过DelegateHandler自动设置Token</span><br><span class="line">    services.AddHttpClient&lt;IThirdPartyClient, ThirdPartyClient&gt;((sp, client) &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        client.Timeout &#x3D; TimeSpan.FromSeconds(5);</span><br><span class="line">        client.BaseAddress &#x3D; new Uri(appSettingConfig.HttpClientConfig.HttpClientMembers.FirstOrDefault(x &#x3D;&gt; x.Name &#x3D;&#x3D; &quot;third&quot;).BaseUrl);</span><br><span class="line">    &#125;).AddClientAccessTokenHandler(&quot;idp&quot;);</span><br><span class="line"></span><br><span class="line">    return services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在日常开发过程中，我们常常需要通过&lt;code&gt;OAUTH2&lt;/code&gt;去接入一些第三方站点，一般分为一下三个步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;l
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>EntityFramework Core 最佳实践</title>
    <link href="https://loremipsumsharp.github.io/2022/01/10/EntityFramework%20Core%E6%9C%80EntityFramework%20Core%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://loremipsumsharp.github.io/2022/01/10/EntityFramework%20Core%E6%9C%80EntityFramework%20Core%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2022-01-10T15:44:00.000Z</published>
    <updated>2022-01-11T07:26:08.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="纯查询场景启用实体跟踪"><a href="#纯查询场景启用实体跟踪" class="headerlink" title="纯查询场景启用实体跟踪"></a>纯查询场景启用实体跟踪</h2><p>对于一些纯粹的查询接口，不涉及到修改，新增的业务场景，在使用Ef Core时，可以关闭实体跟踪功能，可以提升一定性能，eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var userList &#x3D; dbContext.Users.AsNoTracking().ToListAsync();&#x2F;&#x2F;当使用AsNoTracking()后，通过IQueryable得到的实体列表不会被DbContext跟踪到</span><br></pre></td></tr></table></figure><h2 id="重复跟踪实体对象"><a href="#重复跟踪实体对象" class="headerlink" title="重复跟踪实体对象"></a>重复跟踪实体对象</h2><p>对于那些不是通过<code>AsNoTracking()</code>得到的实体对象，Ef Core内部会自动通过<code>ChangeTracker</code>对这些实体对象进行跟踪，当需要将实体变更持久化到数据库时，不需要重复调用<code>Update</code>方法对实体对象进行跟踪。</p><p>错误示范：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var user &#x3D; dbContext.Users.FirstOrDefault(x&#x3D;&gt;x.Id &#x3D;&#x3D; 1);</span><br><span class="line">user.Name &#x3D; &quot;Loremipsum&quot;;</span><br><span class="line">dbContext.Users.Update(user); &#x2F;&#x2F; 这句话是不必要的</span><br><span class="line">dbContext.Users.SaveChanges();</span><br></pre></td></tr></table></figure><p>正确示范:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var user &#x3D; dbContext.Users.FirstOrDefault(x&#x3D;&gt;x.Id &#x3D;&#x3D; 1);</span><br><span class="line">user.Name &#x3D; &quot;Loremipsum&quot;;</span><br><span class="line">dbContext.Users.SaveChanges();</span><br></pre></td></tr></table></figure><h2 id="避免查询断言中的常量表达式"><a href="#避免查询断言中的常量表达式" class="headerlink" title="避免查询断言中的常量表达式"></a>避免查询断言中的常量表达式</h2><p>Ef Core底层会将断言中的<code>lambda</code>表达式树进行编译并缓存，在开发，如果我们的查询中存在大量常量表达式，可能会导致内存泄漏</p><p>错误示范:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var user1 &#x3D; dbContext.Users.FirstOrDefault(x&#x3D;&gt;x.Id &#x3D;&#x3D; 1);</span><br><span class="line">var user2 &#x3D; dbContext.Users.FirstOrDefault(x&#x3D;&gt;x.Id &#x3D;&#x3D; 2);</span><br></pre></td></tr></table></figure><p>正确示范：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var id &#x3D; 1;</span><br><span class="line">var user1 &#x3D; dbContext.Users.FirstOrDefault(x&#x3D;&gt;x.Id &#x3D;&#x3D; id);</span><br><span class="line">id &#x3D; 2;</span><br><span class="line">var user2 &#x3D; dbContext.Users.FirstOrDefault(x&#x3D;&gt;x.Id &#x3D;&#x3D; id);</span><br></pre></td></tr></table></figure><h1 id="一些常见性能优化的点"><a href="#一些常见性能优化的点" class="headerlink" title="一些常见性能优化的点"></a>一些常见性能优化的点</h1><h2 id="Dapper与Ef-Core混用"><a href="#Dapper与Ef-Core混用" class="headerlink" title="Dapper与Ef Core混用"></a>Dapper与Ef Core混用</h2><p>这是一种非常常见的实践，理由如下：</p><ol><li>Ef Core复杂查询自动生成的Sql性能不理想</li><li>Ef Core需要一定配置才可以自动带出Dto，没有Dapper方便</li></ol><p>对于一些接入层的的复杂查询场景，用手写sql的方式可以获得更好的性能。</p><p>Dapper是<code>IDbConnection</code>的一个Extension库，例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string sql &#x3D; &quot;select * from users u  where u.Name like &#39;%loremipsum%&#39;&quot;;</span><br><span class="line">var userList &#x3D; _dbContext.Database.GetDbConnection().QueryAsync&lt;SomeDto&gt;(sql);</span><br></pre></td></tr></table></figure><h2 id="使用Lazy-Load而不是使用-Eager-Load"><a href="#使用Lazy-Load而不是使用-Eager-Load" class="headerlink" title="使用Lazy Load而不是使用 Eager Load"></a>使用Lazy Load而不是使用 Eager Load</h2><p>在Ef Core中Lazy Load默认是不开启的，需要进行如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">services.AddDbContext&lt;TestDbContext&gt;(opt&#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">   &#x2F;&#x2F; 省略</span><br><span class="line">   opt.UseLazyLoadingProxies();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在项目文件中引入如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;PackageReference Include&#x3D;&quot;Microsoft.EntityFrameworkCore.Proxies&quot; Version&#x3D;&quot;5.0.10&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><ol><li>减少代码量</li></ol><p>Eager Load我们需要使用<code>Include</code>去获取导航属性，反之Lazy Load当我们访问导航属性的<code>Getter</code>时可以直接隐式获得这个导航属性</p><ol start="2"><li>Dto 投影</li></ol><p>当我们需要生成一个复杂的Dto的时候，我们不得不用使用<code>Include</code>，然后再将导航属性投影到Dto上面，假如我们的Dto只需要导航属性上面的2个Properties，我们仍然不得不查出导航属性上面所有的Properties</p><p>使用Lazy Proxy与<a href="https://docs.automapper.org/en/stable/Queryable-Extensions.html" target="_blank" rel="noopener">AutoMapper QueryExtensions</a>可以减少投影过程中带来的损耗</p><h2 id="非必要场景，不要使用Code-First"><a href="#非必要场景，不要使用Code-First" class="headerlink" title="非必要场景，不要使用Code First"></a>非必要场景，不要使用Code First</h2><ol><li>锁冲突：Code First生成的数据库模型会自动对关联关系生成外键，外键对数据库的性能造成一定影响，高并发场景下锁冲突的概率会大大增高</li><li>在多人合作开发场景下，Code First的Migrations不易管理</li></ol><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="CLR函数到MySQL函数的映射"><a href="#CLR函数到MySQL函数的映射" class="headerlink" title="CLR函数到MySQL函数的映射"></a>CLR函数到MySQL函数的映射</h2><p>在使用Ef Core开发应用时，我们经常会发现我们的断言没办法正确的被翻译为Sql,很多时候是因为你的断言中包含了特定的函数，而这些函数不能被<code>Pomelo</code>所理解。</p><p><code>Pomelo</code>驱动对一些常见的CLR函数到MySQL函数的映射都进行了处理，那么当我们遇到一些Pomelo无法理解的CLR函数的时候，我们应该怎么样让他映射成一个MySQL函数呢：例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;  使用前先确认函数已经通过HasDbFunction注册到DbContext,注意，单位是秒</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    public static class MySqlDbFunctions</span><br><span class="line">    &#123;</span><br><span class="line">        [DbFunction(&quot;STR_TO_DATE&quot;)]</span><br><span class="line">        public static DateTime STR_TO_DATE(string dateStr, string format) &#x3D;&gt; throw new NotSupportedException();</span><br><span class="line">        [DbFunction(&quot;CONCAT&quot;)]</span><br><span class="line">        public static string CONCAT3(string str1,string str2,string str3) &#x3D;&gt; throw new NotSupportedException();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    protected override void OnModelCreating(ModelBuilder modelBuilder)</span><br><span class="line">        &#123;</span><br><span class="line">            modelBuilder</span><br><span class="line">.HasDbFunction(() &#x3D;&gt; MySqlDbFunctions.STR_TO_DATE(default(string), default(string)));</span><br><span class="line">            modelBuilder</span><br><span class="line">.HasDbFunction(() &#x3D;&gt; MySqlDbFunctions.CONCAT3(default, default, default));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>通过如上配置，可以将<code>STR_TO_DATA</code>，<code>CONCAT3</code>自动映射到MySql对应的库函数中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常见错误&quot;&gt;&lt;a href=&quot;#常见错误&quot; class=&quot;headerlink&quot; title=&quot;常见错误&quot;&gt;&lt;/a&gt;常见错误&lt;/h1&gt;&lt;h2 id=&quot;纯查询场景启用实体跟踪&quot;&gt;&lt;a href=&quot;#纯查询场景启用实体跟踪&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>安装Kubernetes Dashboard</title>
    <link href="https://loremipsumsharp.github.io/2021/11/13/%E5%AE%89%E8%A3%85Kubernetes%20Dashboard/"/>
    <id>https://loremipsumsharp.github.io/2021/11/13/%E5%AE%89%E8%A3%85Kubernetes%20Dashboard/</id>
    <published>2021-11-13T06:30:00.000Z</published>
    <updated>2021-11-13T06:44:53.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="获取安装文件"><a href="#获取安装文件" class="headerlink" title="获取安装文件"></a>获取安装文件</h2><p>首先打开<a href="!https://github.com/kubernetes/dashboard">官方仓库</a>,将dashboard.yml文件拷贝到k8s master主机上。由于dashboard无法支持外部直接访问，所以我们需要对yaml文件的配置内容进行少量修改:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">    - port: 443</span><br><span class="line">      targetPort: 8443</span><br><span class="line">      nodePort: 30001</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br></pre></td></tr></table></figure><p>这里将<code>kubernetes-dashboard</code>的对应的<code>Service</code>修改为NodePort,让服务可以直接对外暴露。</p><p>修改完毕后，执行部署</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f dashboard.yml</span><br></pre></td></tr></table></figure><h3 id="验证部署"><a href="#验证部署" class="headerlink" title="验证部署"></a>验证部署</h3><p>执行部署后，稍等片刻（拉去镜像需要耗费一定时间）后验证相关pod有没有在运行</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> kubectl -n kubernetes-dashboard get all</span></span><br><span class="line">NAME                                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/dashboard-metrics-scraper-c45b7869d-9wclb   1/1     Running   0          51m</span><br><span class="line">pod/kubernetes-dashboard-576cb95f94-v4lk2       1/1     Running   0          51m</span><br><span class="line"></span><br><span class="line">NAME                                TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)         AGE</span><br><span class="line">service/dashboard-metrics-scraper   ClusterIP   10.104.124.208   &lt;none&gt;        8000/TCP        51m</span><br><span class="line">service/kubernetes-dashboard        NodePort    10.99.67.103     &lt;none&gt;        443:30001/TCP   50m</span><br><span class="line"></span><br><span class="line">NAME                                        READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/dashboard-metrics-scraper   1/1     1            1           51m</span><br><span class="line">deployment.apps/kubernetes-dashboard        1/1     1            1           51m</span><br><span class="line"></span><br><span class="line">NAME                                                  DESIRED   CURRENT   READY   AGE</span><br><span class="line">replicaset.apps/dashboard-metrics-scraper-c45b7869d   1         1         1       51m</span><br><span class="line">replicaset.apps/kubernetes-dashboard-576cb95f94       1         1         1       51m</span><br></pre></td></tr></table></figure><h3 id="配置权限"><a href="#配置权限" class="headerlink" title="配置权限"></a>配置权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount              </span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io&#x2F;v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin                ## 将ServiceAccount授权，加入到 cluster-amdin组中，这个组具有对k8s超级管理员权限</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br></pre></td></tr></table></figure><p>获取用户token，用于登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk &#39;&#123;print $1&#125;&#39;)</span><br></pre></td></tr></table></figure><h3 id="登录验证"><a href="#登录验证" class="headerlink" title="登录验证"></a>登录验证</h3><p><img src="https://raw.githubusercontent.com/LoremipsumSharp/Images/master/img/WeChat%20Screenshot_20211113144133.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;获取安装文件&quot;&gt;&lt;a href=&quot;#获取安装文件&quot; class=&quot;headerlink&quot; title=&quot;获取安装文件&quot;&gt;&lt;/a&gt;获取安装文件&lt;/h2&gt;&lt;p&gt;首先打开&lt;a href=&quot;!https://github.com/kubernetes/dashboard&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>使用BenchmarkDotNet测试Envoy中Grpc-Json协议转化的实际性能损耗</title>
    <link href="https://loremipsumsharp.github.io/2021/11/08/%E4%BD%BF%E7%94%A8BenchmarkDotNet%E6%B5%8B%E8%AF%95Envoy%E4%B8%ADGrpc-Json%E5%8D%8F%E8%AE%AE%E8%BD%AC%E5%8C%96%E7%9A%84%E5%AE%9E%E9%99%85%E6%80%A7%E8%83%BD%E6%8D%9F%E8%80%97/"/>
    <id>https://loremipsumsharp.github.io/2021/11/08/%E4%BD%BF%E7%94%A8BenchmarkDotNet%E6%B5%8B%E8%AF%95Envoy%E4%B8%ADGrpc-Json%E5%8D%8F%E8%AE%AE%E8%BD%AC%E5%8C%96%E7%9A%84%E5%AE%9E%E9%99%85%E6%80%A7%E8%83%BD%E6%8D%9F%E8%80%97/</id>
    <published>2021-11-07T20:00:00.000Z</published>
    <updated>2021-11-07T20:09:35.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Envoy目前作为最流行的的Service Mesh边车代理，提供了大量开箱即用的功能，极大的方便了开发人员。先前笔者就通过使用Envoy的Grpc-Json协议转化器，使得大量内部Grpc接口能够对Client端直接输出。那么Grpc-Json协议转化器会带来多少的性能损耗呢？相关项目上线后确实没有感觉出来，如果要找到确切的答案，还需要进行一定的测试才能给出</p><h2 id="实验方法"><a href="#实验方法" class="headerlink" title="实验方法"></a>实验方法</h2><p>为了测试<code>GrpcJsonTranscoder</code>接口的性能损耗，可以设计以下三个Grpc接口,这三个Grpc接口会通过Envoy进行协议转化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option csharp_namespace &#x3D; &quot;GrpcJsonTranscondingPerfTest&quot;;</span><br><span class="line">import &quot;google&#x2F;api&#x2F;annotations.proto&quot;;</span><br><span class="line"></span><br><span class="line">package echo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">service EchoService &#123;</span><br><span class="line"></span><br><span class="line">  rpc EchoWithSmallPayloadByGet (SmallPayloadRequest) returns (SmallPayloadResponse)&#123;</span><br><span class="line">    option (google.api.http) &#x3D; &#123;</span><br><span class="line">      get: &quot;&#x2F;small&quot;</span><br><span class="line">    &#125;; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rpc EchoWithSmallPayloadByPost (SmallPayloadRequest) returns (SmallPayloadResponse)&#123;</span><br><span class="line">    option (google.api.http) &#x3D; &#123;</span><br><span class="line">      post: &quot;&#x2F;small&quot;</span><br><span class="line">      body: &quot;*&quot;</span><br><span class="line">    &#125;; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  rpc EchoWithMassivePayloadByPost (MassivePayloadRequest) returns (MassivePayloadResponse)&#123;</span><br><span class="line">    option (google.api.http) &#x3D; &#123;</span><br><span class="line">      post: &quot;&#x2F;massive&quot;</span><br><span class="line">      body: &quot;*&quot;</span><br><span class="line">    &#125;; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message SmallPayloadRequest &#123;</span><br><span class="line">  string Message &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message SmallPayloadResponse &#123;</span><br><span class="line">  string Message &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message MassivePayloadRequest &#123;</span><br><span class="line">  repeated string StringList &#x3D; 1;</span><br><span class="line">repeated int32 IntList&#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message MassivePayloadResponse &#123;</span><br><span class="line">  repeated string StringList &#x3D; 1;</span><br><span class="line">repeated int32 IntList&#x3D; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，为了对比Envoy与原生ASP.NET CORE的性能损耗，还需三个原生的Restful接口:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[ApiController]</span><br><span class="line">public class Echo : ControllerBase</span><br><span class="line">&#123;</span><br><span class="line">    [HttpGet(&quot;small&quot;)]</span><br><span class="line">    public Task&lt;GrpcJsonTranscondingPerfTest.Common.Models.SmallPayloadResponse&gt; EchoWithSmallPayloadByGet([FromQuery] GrpcJsonTranscondingPerfTest.Common.Models.SmallPayloadRequest request)</span><br><span class="line">    &#123;</span><br><span class="line">       &#x2F;&#x2F; ... 省略</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [HttpPost(&quot;small&quot;)]</span><br><span class="line">    public Task&lt;GrpcJsonTranscondingPerfTest.Common.Models.SmallPayloadResponse&gt; EchoWithSmallPayloadByPost([FromBody] GrpcJsonTranscondingPerfTest.Common.Models.SmallPayloadRequest request)</span><br><span class="line">    &#123;</span><br><span class="line">       &#x2F;&#x2F; ... 省略</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [HttpPost(&quot;massive&quot;)]</span><br><span class="line">    public Task&lt;GrpcJsonTranscondingPerfTest.Common.Models.MassivePayloadResponse&gt; EchoWithMassivePayloadByPost([FromBody] GrpcJsonTranscondingPerfTest.Common.Models.MassivePayloadRequest request)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; ... 省略</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述设计了验证以下3个问题:</p><ol><li>get请求与post请求</li><li>对于post请求，较小的payload与较大的payload会带来多少性能损耗</li><li>原生的ASP.NET Core相比较Envoy+Grpc谁拥有更好的性能?</li></ol><h3 id="测试工具与环境"><a href="#测试工具与环境" class="headerlink" title="测试工具与环境"></a>测试工具与环境</h3><h4 id="Client环境"><a href="#Client环境" class="headerlink" title="Client环境"></a>Client环境</h4><p>工具: BenchmarkDotNet v0.13.1</p><p>OS: Windows 10.0.19043.1288 (21H1/May2021Update)</p><p>CPU: Intel Core i7-8750H CPU 2.20GHz (Coffee Lake), 1 CPU, 12 logical and 6 physical cores</p><p>.NET SDK: 5.0.104</p><h4 id="Server环境"><a href="#Server环境" class="headerlink" title="Server环境"></a>Server环境</h4><p>边车代理: Envoy v1.19.1</p><p>OS: ubuntu 20.04</p><p>CPU: Intel Core i7-4710MQ CPU 2.50GHz (Haswell), 1 CPU, 8 logical and 4 physical cores</p><p>.NET SDK: 5.0.502</p><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>由于这个测试输出较长，这里仅仅截取结论部分，如果对相关细节感兴趣，可以参考<a href="https://github.com/LoremipsumSharp/GrpcJsonTranscondingPerfTest" target="_blank" rel="noopener">测试源码</a></p><p>ASP.NET Core原生调用</p><table><thead><tr><th>Method</th><th align="right">Mean</th><th align="right">Error</th><th align="right">StdDev</th></tr></thead><tbody><tr><td>SendSmallPayloadByGet</td><td align="right">5.954 ms</td><td align="right">0.1158 ms</td><td align="right">0.3011 ms</td></tr><tr><td>SendSmallPayloadByPost</td><td align="right">6.274 ms</td><td align="right">0.1614 ms</td><td align="right">0.4604 ms</td></tr><tr><td>SendMassivePayloadByPost</td><td align="right">6.952 ms</td><td align="right">0.2388 ms</td><td align="right">0.7004 ms</td></tr></tbody></table><p>Grpc原生调用</p><table><thead><tr><th>Method</th><th align="right">Mean</th><th align="right">Error</th><th align="right">StdDev</th></tr></thead><tbody><tr><td>SendSmallPayloadByGet</td><td align="right">6.274 ms</td><td align="right">0.3606 ms</td><td align="right">1.0228 ms</td></tr><tr><td>SendSmallPayloadByPost</td><td align="right">6.350 ms</td><td align="right">0.3220 ms</td><td align="right">0.8704 ms</td></tr><tr><td>SendMassivePayloadByPost</td><td align="right">5.520 ms</td><td align="right">0.1093 ms</td><td align="right">0.1258 ms</td></tr></tbody></table><p>Grpc+Envoy调用</p><table><thead><tr><th>Method</th><th align="right">Mean</th><th align="right">Error</th><th align="right">StdDev</th></tr></thead><tbody><tr><td>SendSmallPayloadByGet</td><td align="right">6.989 ms</td><td align="right">0.1394 ms</td><td align="right">0.3367 ms</td></tr><tr><td>SendSmallPayloadByPost</td><td align="right">7.489 ms</td><td align="right">0.1518 ms</td><td align="right">0.4207 ms</td></tr><tr><td>SendMassivePayloadByPost</td><td align="right">7.874 ms</td><td align="right">0.1988 ms</td><td align="right">0.5800 ms</td></tr></tbody></table><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>从测试接口可以看出，当使用Envoy对Grpc接口进行协议转换的时候，随着payload越大，整个耗时越长，但是实际的整个性能损耗对于大部分业务场景来讲，都是可以接受的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;Envoy目前作为最流行的的Service Mesh边车代理，提供了大量开箱即用的功能，极大的方便了开发人员。先前笔者就通过使用Envoy的
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>使用Diagnostics Client实时获取.NetCore应用的性能指标</title>
    <link href="https://loremipsumsharp.github.io/2021/11/06/%E4%BD%BF%E7%94%A8Diagnostics%20Client%E5%AE%9E%E6%97%B6%E8%8E%B7%E5%8F%96.Net%20Core%E5%BA%94%E7%94%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/"/>
    <id>https://loremipsumsharp.github.io/2021/11/06/%E4%BD%BF%E7%94%A8Diagnostics%20Client%E5%AE%9E%E6%97%B6%E8%8E%B7%E5%8F%96.Net%20Core%E5%BA%94%E7%94%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</id>
    <published>2021-11-06T05:40:09.000Z</published>
    <updated>2021-11-06T19:22:48.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>.NET Core 3.0引入了一个新的Cli工具<code>dotnet-counters</code>,通过<code>dotnet-counters</code>，我们可以很轻松的获取.NET Runtime的相关性能指标，如下所示：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> dotnet-counters list</span></span><br><span class="line">Showing well-known counters only. Specific processes may support additional counters.</span><br><span class="line"></span><br><span class="line">System.Runtime</span><br><span class="line">    cpu-usage                                    Amount of time the process has utilized the CPU (ms)</span><br><span class="line">    working-set                                  Amount of working set used by the process (MB)</span><br><span class="line">    gc-heap-size                                 Total heap size reported by the GC (MB)</span><br><span class="line">    gen-0-gc-count                               Number of Gen 0 GCs per interval</span><br><span class="line">    gen-1-gc-count                               Number of Gen 1 GCs per interval</span><br><span class="line">    gen-2-gc-count                               Number of Gen 2 GCs per interval</span><br><span class="line">    time-in-gc                                   % time in GC since the last GC</span><br><span class="line">    gen-0-size                                   Gen 0 Heap Size</span><br><span class="line">    gen-1-size                                   Gen 1 Heap Size</span><br><span class="line">    gen-2-size                                   Gen 2 Heap Size</span><br><span class="line">    loh-size                                     LOH Heap Size</span><br><span class="line">    alloc-rate                                   Allocation Rate</span><br><span class="line">    assembly-count                               Number of Assemblies Loaded</span><br><span class="line">    exception-count                              Number of Exceptions per interval</span><br><span class="line">    threadpool-thread-count                      Number of ThreadPool Threads</span><br><span class="line">    monitor-lock-contention-count                Monitor Lock Contention Count</span><br><span class="line">    threadpool-queue-length                      ThreadPool Work Items Queue Length</span><br><span class="line">    threadpool-completed-items-count             ThreadPool Completed Work Items Count</span><br><span class="line">    active-timer-count                           Active Timers Count</span><br><span class="line"></span><br><span class="line">Microsoft.AspNetCore.Hosting</span><br><span class="line">    requests-per-second                  Request rate</span><br><span class="line">    total-requests                       Total number of requests</span><br><span class="line">    current-requests                     Current number of requests</span><br><span class="line">    failed-requests                      Failed number of requests</span><br></pre></td></tr></table></figure><p>这些性能指标极大的方便了线上应用的故障诊断，但是在很多情况下，开发人员及运维人员是无法24h去盯着这些指标，往往是在监控告警后才会开始进行问题的排查，在这种背景下，会出现以下两个需求：</p><ol><li>通过性能指标进行告警</li><li>对性能指标这一类时序数据进行存储，用于后续分析</li></ol><p>很显然为了满足上述的两个需求，仅仅通过<code>dotnet-counters</code>是很难实现的，是否存在一种可编程的方法来获取上述的性能指标？答案是就是<code>Microsoft.Diagnostics.NETCore.Client</code></p><h2 id="Microsoft-Diagnostics-NETCore-Client"><a href="#Microsoft-Diagnostics-NETCore-Client" class="headerlink" title="Microsoft.Diagnostics.NETCore.Client"></a>Microsoft.Diagnostics.NETCore.Client</h2><p>实际上，如果查阅<code>dotnet-counters</code>，<code>dotnet-gcdump</code>的源码就可以发现，这些cli诊断工具的底层实际上是基于<code>Microsoft.Diagnostics.NETCore.Client</code>，那么很显然，我们可以通过引用Nuget包的形式<code>Microsoft.Diagnostics.NETCore.Client</code>，通过调用相关API来实现对.NET Core进程的性能指标收集。</p><p>如下所示，下述代码，笔者将这一系列指标通过WebSocket传递到前端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">[HttpGet(&quot;&#x2F;counter&quot;)]</span><br><span class="line">      public async Task PerformanceCounter([FromQuery] string counterName, [FromQuery] string service &#x3D; &quot;nhost&quot;, [FromQuery] string interval &#x3D; &quot;10 &quot;)</span><br><span class="line">      &#123;</span><br><span class="line">          &#x2F;&#x2F; 是否是websocket连接?</span><br><span class="line">          if (!HttpContext.WebSockets.IsWebSocketRequest)</span><br><span class="line">              throw new NotSupportedException(&quot;ws is required for getting performance counter&quot;);</span><br><span class="line"></span><br><span class="line">          </span><br><span class="line">          var websocket &#x3D; await HttpContext.WebSockets.AcceptWebSocketAsync();</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; 获取System.Runtime相关counter,每10秒获取一些</span><br><span class="line">          var providers &#x3D; new List&lt;EventPipeProvider&gt;()</span><br><span class="line">          &#123;</span><br><span class="line">            new EventPipeProvider(&quot;System.Runtime&quot;,</span><br><span class="line">            EventLevel.Informational, arguments: new Dictionary&lt;string, string&gt;</span><br><span class="line">            &#123;</span><br><span class="line">              &#123;&quot;EventCounterIntervalSec&quot;, interval&#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          var client &#x3D; new DiagnosticsClient(Process.GetCurrentProcess().Id);</span><br><span class="line">          var session &#x3D; client.StartEventPipeSession(providers, false);</span><br><span class="line">          var source &#x3D; new EventPipeEventSource(session.EventStream);</span><br><span class="line">          var output &#x3D; new Subject&lt;string&gt;();</span><br><span class="line">          source.Dynamic.All +&#x3D; obj &#x3D;&gt;</span><br><span class="line">          &#123;</span><br><span class="line">              if (obj.EventName &#x3D;&#x3D; &quot;EventCounters&quot;)</span><br><span class="line">              &#123;</span><br><span class="line">                  var payload &#x3D; (IDictionary&lt;string, object&gt;)obj.PayloadValue(0);</span><br><span class="line"></span><br><span class="line">                  if (!string.IsNullOrWhiteSpace(counterName))</span><br><span class="line">                      payload &#x3D; payload.Where(x &#x3D;&gt; x.Value.ToString().TryParse(out var jObj) &amp;&amp;</span><br><span class="line">                      string.Equals(counterName, jObj[&quot;Name&quot;]?.ToString()))</span><br><span class="line">                      .ToDictionary(x &#x3D;&gt; x.Key, x &#x3D;&gt; x.Value);</span><br><span class="line">                  foreach (var item in payload)</span><br><span class="line">                  &#123;</span><br><span class="line">                      output.OnNext(item.Value.ToString());</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          this.HttpContext.RequestAborted.Register(() &#x3D;&gt; session.Dispose());</span><br><span class="line">          var task &#x3D; Task.Factory.StartNew(</span><br><span class="line">                          () &#x3D;&gt; source.Process(),</span><br><span class="line">                          HttpContext.RequestAborted,</span><br><span class="line">                          TaskCreationOptions.LongRunning, TaskScheduler.Default);</span><br><span class="line"></span><br><span class="line">          await Echo(websocket, output);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>笔者先前在做相关的应用性能监控平台遇到了这个问题，最开始笔者是打算直接使用一个进程将cli工具<code>dotnet-counters</code>启动起来，并对其标准输出流进行截取，后来发现这样做实在太麻烦了，光字符串处理就要做一大堆判断。后来通过查阅官方的源码，发现使用<code>Microsoft.Diagnostics.NETCore.Client</code>才是标准做法，并进行了尝试及验证，发现这个方案是可行的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;.NET Core 3.0引入了一个新的Cli工具&lt;code&gt;dotnet-counters&lt;/code&gt;,通过&lt;code&gt;dotnet-c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>通过Reactive.NET来理解Async&amp;Await</title>
    <link href="https://loremipsumsharp.github.io/2021/08/16/%E9%80%9A%E8%BF%87Reactive.NET%E6%9D%A5%E7%90%86%E8%A7%A3Async&amp;Await/"/>
    <id>https://loremipsumsharp.github.io/2021/08/16/%E9%80%9A%E8%BF%87Reactive.NET%E6%9D%A5%E7%90%86%E8%A7%A3Async&amp;Await/</id>
    <published>2021-08-15T17:28:00.000Z</published>
    <updated>2021-08-15T18:19:19.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>如果一个.NET应用通过async/await执行一个异步方法时，一旦遇到一些特定的I/O操作，</p><p>如磁盘I/O:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File.ReadAllTextAsync</span><br></pre></td></tr></table></figure><p>网络I/O:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpClient.GetStringAsync</span><br></pre></td></tr></table></figure><p>这个时候工作线程会被释放掉，取而代之的是I/O线程，I/O线程会去监听操作系统的相关I/O事件(Windows:IOCP,  *niux:epoll)，直到相关I/O事件产生后，将具体的I/O结果返回给应用。当发生具体的I/O操作的时工作线程实际上不会被挂起，可以继续工作(这也是async/await的一个好处之一，减少cpu上下文切换)</p><h2 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h2><p>为了证明猜测的正确性，这里我们使用Reactive.NET中自带的EventLoopScheduler,通过EventLoopScheduler,我们可以保证await之前代码使用执行在一条工作线程之上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public void Test2()</span><br><span class="line">&#123;</span><br><span class="line">    EventLoopScheduler eventLoopScheduler &#x3D; new EventLoopScheduler();</span><br><span class="line"></span><br><span class="line">    System.Text.Encoding.RegisterProvider(System.Text.CodePagesEncodingProvider.Instance);</span><br><span class="line">    var disposeable1 &#x3D; Observable.Create&lt;string&gt;(async observer &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        var client &#x3D; new HttpClient();</span><br><span class="line">        _testOutputHelper.WriteLine($&quot;observable1 started: &#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;);</span><br><span class="line">        var result &#x3D; await client.GetStringAsync(&quot;https:&#x2F;&#x2F;www.baidu.com&quot;);</span><br><span class="line">        observer.OnNext(result);</span><br><span class="line">        observer.OnCompleted();</span><br><span class="line">        _testOutputHelper.WriteLine($&quot;observable1 completed: &#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;);</span><br><span class="line">        return Disposable.Create(() &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            client.Dispose();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;).ObserveOn(eventLoopScheduler).SubscribeOn(eventLoopScheduler)</span><br><span class="line">    .Subscribe(item &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        _testOutputHelper.WriteLine(&quot;observable1 consumed&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    var disposeable2 &#x3D; Observable.Create&lt;string&gt;(async observer &#x3D;&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       var client &#x3D; new HttpClient();</span><br><span class="line">       _testOutputHelper.WriteLine($&quot;observable2 started: &#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;);</span><br><span class="line">       var result &#x3D; await client.GetStringAsync(&quot;https:&#x2F;&#x2F;www.sina.com.cn&quot;);</span><br><span class="line">       observer.OnNext(result);</span><br><span class="line">       observer.OnCompleted();</span><br><span class="line">       _testOutputHelper.WriteLine($&quot;observable2 completed : &#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;);</span><br><span class="line">       return Disposable.Create(() &#x3D;&gt;</span><br><span class="line">       &#123;</span><br><span class="line">           client.Dispose();</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;).ObserveOn(eventLoopScheduler).SubscribeOn(eventLoopScheduler)</span><br><span class="line">   .Subscribe(item &#x3D;&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       _testOutputHelper.WriteLine(&quot;observable2 consumed&quot;);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">    Thread.Sleep(1000 * 30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">observable1 started: 25</span><br><span class="line">observable2 started: 25</span><br><span class="line">observable1 completed: 7</span><br><span class="line">observable1 consumed</span><br><span class="line">observable2 completed : 7</span><br><span class="line">observable2 consumed</span><br></pre></td></tr></table></figure><p>可以看出当observable1被I/O阻塞掉之后，工作线程会继续执行observable2的相关代码，都是同一个线程ID。<br>你可能会好奇为什么completed的时候线程ID是7，那是因为await之后的线程是取决于当前同步上下文，可以参考我另外一篇文章：<br><a href="https://loremipsumsharp.github.io/2021/04/03/Await&Await%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81%E7%9A%84/">Await&amp;Await是如何导致死锁的</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h2&gt;&lt;p&gt;如果一个.NET应用通过async/await执行一个异步方法时，一旦遇到一些特定的I/O操作，&lt;/p&gt;
&lt;p&gt;如磁盘I/O
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>使用Autofixture提高单元测试编写效率</title>
    <link href="https://loremipsumsharp.github.io/2021/06/13/%E4%BD%BF%E7%94%A8Autofixture%E6%8F%90%E9%AB%98%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%BC%96%E5%86%99%E6%95%88%E7%8E%87/"/>
    <id>https://loremipsumsharp.github.io/2021/06/13/%E4%BD%BF%E7%94%A8Autofixture%E6%8F%90%E9%AB%98%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%BC%96%E5%86%99%E6%95%88%E7%8E%87/</id>
    <published>2021-06-13T08:41:09.000Z</published>
    <updated>2021-06-13T09:24:06.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在编写单元测试的过程中，我们常常需要将一些测试的非关注点以Moq的形式去掉，如一些外部的grpc调用、数据库依赖，redis依赖等。eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[Fact]</span><br><span class="line">public async Task TestAddSubscription_WhenExists_ThrownException()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; arrange</span><br><span class="line">    var subscription &#x3D; new Subscription()</span><br><span class="line">    &#123;</span><br><span class="line">        SourceCode &#x3D; &quot;sys_db-pt_role&quot;,</span><br><span class="line">        SourceVersion &#x3D; 2,</span><br><span class="line">        SourceTimestamp &#x3D; 1622014384,</span><br><span class="line">        TargetCode &#x3D; &quot;EU-Target&#x2F;EU-SYS-Db&#x2F;sys_db-pt_role&quot;,</span><br><span class="line">        TargetVersion &#x3D; 0,</span><br><span class="line">        TargetTimestamp &#x3D; 0,</span><br><span class="line">        Status &#x3D; SubscriptionStatus.UnSynchronized,</span><br><span class="line">        LastPullTime &#x3D; DateTime.Now,</span><br><span class="line">        CreateTime &#x3D; DateTime.Now,</span><br><span class="line">        IsEnable &#x3D; true</span><br><span class="line">    &#125;;</span><br><span class="line">    var mockSubscriptionRepo &#x3D; new Mock&lt;ISubscriptionRepository&gt;();</span><br><span class="line">    mockSubscriptionRepo.Setup(x &#x3D;&gt; x.GetSubscription(subscription.SourceCode, subscription.TargetCode))</span><br><span class="line">    .ReturnsAsync(new Subscription());</span><br><span class="line">    var mockTargetServerRepository &#x3D; new Mock&lt;ITargetServerRepository&gt;();</span><br><span class="line">    var mockTargetServerClient &#x3D; new Mock&lt;ITargetServerClient&gt;();</span><br><span class="line">    var mockPushTaskRepository &#x3D; new Mock&lt;IPushTaskRepository&gt;();</span><br><span class="line">    var mockSourceServerClient &#x3D; new Mock&lt;ISourceServerClient&gt;();</span><br><span class="line">    SubscriptionService subscriptionService &#x3D; new SubscriptionService(mockTargetServerRepository.Object,mockSubscriptionRepo.Object,targetServerClient.Object,mockPushTaskRepository.Object,mockSourceServerClient.Object)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; act</span><br><span class="line">    Task act() &#x3D;&gt; subscriptionService.AddSubscription(subscription, new TargetServer(), string.Empty, string.Empty, string.Empty);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; assert</span><br><span class="line">    await Assert.ThrowsAsync&lt;SiteErrorException&gt;(act);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SubscriptionService的定义如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class SubscriptionService : ISubscriptionService</span><br><span class="line">&#123;</span><br><span class="line">   private readonly ITargetServerRepository _targetServerRepository;</span><br><span class="line">   private readonly ISubscriptionRepository _subscriptionRepository;</span><br><span class="line">   private readonly IPushTaskRepository _pushTaskRepository;</span><br><span class="line">   private readonly ITargetServerClient _targetServerClient;</span><br><span class="line">   private readonly ISourceServerClient _sourceServerClient;</span><br><span class="line">   private readonly ILogger&lt;SubscriptionService&gt; _logger;</span><br><span class="line"></span><br><span class="line">   private static string _lockKeyPattern &#x3D; &quot;&#123;0&#125;:&#123;1&#125;:SubscriptionSync&quot;;</span><br><span class="line">   private static readonly ConcurrentDictionary&lt;string, SemaphoreSlim&gt; _locks &#x3D; new ConcurrentDictionary&lt;string, SemaphoreSlim&gt;();</span><br><span class="line"></span><br><span class="line">   public SubscriptionService(ITargetServerRepository targetServerRepository, ISubscriptionRepository subscriptionRepository, ITargetServerClient targetServerClient, IPushTaskRepository pushTaskRepository, ISourceServerClient sourceServerClient, ILogger&lt;SubscriptionService&gt; logger)</span><br><span class="line">   &#123;</span><br><span class="line">       _targetServerRepository &#x3D; targetServerRepository;</span><br><span class="line">       _subscriptionRepository &#x3D; subscriptionRepository;</span><br><span class="line">       _targetServerClient &#x3D; targetServerClient;</span><br><span class="line">       _pushTaskRepository &#x3D; pushTaskRepository;</span><br><span class="line">       _sourceServerClient &#x3D; sourceServerClient;</span><br><span class="line">       _logger &#x3D; logger;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述写法存在的弊端：</p><ol><li>需要Mock大量对象，导致单元测试的arrange阶段极为冗长</li><li>如果SubscriptionServices的构造函数发生变化，那么这个单元测试无法通过</li></ol><p>实际上，在上面的这个单元测试，我们仅仅关注ISubscriptionRepository，那么有没有办法通过一些手段来解决问题1、2呢？</p><h2 id="使用Autofixture编写单元测试"><a href="#使用Autofixture编写单元测试" class="headerlink" title="使用Autofixture编写单元测试"></a>使用Autofixture编写单元测试</h2><p>AutoFixture 是一个 .NET 的开源框架，主要设计目的是最小化单元测试的arrange阶段。可以让开发者把重点放在测试的目标而不是设置测试场景。</p><p>通过Autofixture,可以实现Moq的自动化，我们只需要将我们的精力聚焦在我们要测试的点上，也就是说我们只需要关注我们测试需要用到的一些Mock对象。</p><p>通过Autofixture重构后的代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class TestSubscriptionService</span><br><span class="line">&#123;</span><br><span class="line">    private readonly Fixture _fixture;</span><br><span class="line">    public TestSubscriptionService()</span><br><span class="line">    &#123;</span><br><span class="line">        _fixture &#x3D; new Fixture();</span><br><span class="line">        _fixture.Customize(new AutoMoqCustomization());</span><br><span class="line">    &#125;</span><br><span class="line">    [Fact]</span><br><span class="line">    public async Task TestAddSubscription_WhenExists_ThrownException()</span><br><span class="line">    &#123;</span><br><span class="line">        var subscription &#x3D; new Subscription()</span><br><span class="line">        &#123;</span><br><span class="line">            SourceCode &#x3D; &quot;sys_db-pt_role&quot;,</span><br><span class="line">            SourceVersion &#x3D; 2,</span><br><span class="line">            SourceTimestamp &#x3D; 1622014384,</span><br><span class="line">            TargetCode &#x3D; &quot;EU-Target&#x2F;EU-SYS-Db&#x2F;sys_db-pt_role&quot;,</span><br><span class="line">            TargetVersion &#x3D; 0,</span><br><span class="line">            TargetTimestamp &#x3D; 0,</span><br><span class="line">            Status &#x3D; SubscriptionStatus.UnSynchronized,</span><br><span class="line">            LastPullTime &#x3D; DateTime.Now,</span><br><span class="line">            CreateTime &#x3D; DateTime.Now,</span><br><span class="line">            IsEnable &#x3D; true</span><br><span class="line">        &#125;;</span><br><span class="line">        var mockSubscriptionRepo &#x3D; new Mock&lt;ISubscriptionRepository&gt;();</span><br><span class="line">        mockSubscriptionRepo.Setup(x &#x3D;&gt; x.GetSubscription(subscription.SourceCode, subscription.TargetCode))</span><br><span class="line">            .ReturnsAsync(new Subscription());</span><br><span class="line">        _fixture.Register&lt;ISubscriptionRepository&gt;(() &#x3D;&gt; mockSubscriptionRepo.Object);</span><br><span class="line">        SubscriptionService subscriptionService &#x3D; _fixture.Create&lt;SubscriptionService&gt;();</span><br><span class="line"></span><br><span class="line">        Task act() &#x3D;&gt; subscriptionService.AddSubscription(subscription, new TargetServer(), string.Empty, string.Empty, string.Empty);</span><br><span class="line"></span><br><span class="line">        await Assert.ThrowsAsync&lt;SiteErrorException&gt;(act);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示:</p><ol><li>当构造函数发生变更后，我们无需重写单元测试，Autofixture会自动帮我们Mock一些非测试关注的对象</li><li>极大的简化了arrange阶段的代码量</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/34788365/how-to-add-a-specific-implementation-of-a-mock-created-with-autofixture" target="_blank" rel="noopener">How to add a specific implementation of a Mock created with Autofixture</a></p><p><a href="https://blog.ploeh.dk/2011/04/19/ConstructorstrategiesforAutoFixture/" target="_blank" rel="noopener">Constructor strategies for AutoFixture</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在编写单元测试的过程中，我们常常需要将一些测试的非关注点以Moq的形式去掉，如一些外部的grpc调用、数据库依赖，redis依赖等。eg:&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>使用SourceLink调试Nuget包源码</title>
    <link href="https://loremipsumsharp.github.io/2021/05/16/%E4%BD%BF%E7%94%A8SourceLink%E8%B0%83%E8%AF%95Nuget%E5%8C%85/"/>
    <id>https://loremipsumsharp.github.io/2021/05/16/%E4%BD%BF%E7%94%A8SourceLink%E8%B0%83%E8%AF%95Nuget%E5%8C%85/</id>
    <published>2021-05-16T15:27:39.659Z</published>
    <updated>2021-05-16T16:25:02.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在日常开发中，我们将一些封装好的类库以nuget包的形式发布到nuget服务器上，通过引用这些nuget包来增加开发效率，减少重复代码。由于nuget包的本质上是一个dll，在使用nuget包的过程中，我们无法直接调试与之对应的源码，当一些以nuget包提供的第三方类库报错或发生异常时，我们往往需要去相应的仓库克隆相关的源码，并将nuget包引用替换为源码引用，通过直接源码调试来定位具体的问题。</p><p>那么是否存在一种开箱即用的工具，能够应付上述的场景?答案是:<a href="https://github.com/dotnet/sourcelink" target="_blank" rel="noopener">SourceLink</a></p><p>SourceLink是Microsoft的一个开源项目，开发者只需在项目文件(.csproj)进行简单的配置便可以让生成的nuget包嵌入相关的源码信息。当开发者进行调试的时候，.NET Debugger便会利用pdb文件中的源码信息，直接将断点定位具体源码，用户无需再去克隆相关源码进行调试。</p><p>目前SourceLink支持的最低.NET CORE SDK版本是2.1.300</p><h2 id="项目设置"><a href="#项目设置" class="headerlink" title="项目设置"></a>项目设置</h2><p>在项目文件增加如下的配置项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;PropertyGroup&gt;</span><br><span class="line">    &lt;PublishRepositoryUrl&gt;true&lt;&#x2F;PublishRepositoryUrl&gt;</span><br><span class="line">    &lt;EmbedUntrackedSources&gt;true&lt;&#x2F;EmbedUntrackedSources&gt;</span><br><span class="line">    &lt;IncludeSymbols&gt;true&lt;&#x2F;IncludeSymbols&gt;</span><br><span class="line">    &lt;SymbolPackageFormat&gt;snupkg&lt;&#x2F;SymbolPackageFormat&gt;</span><br><span class="line">    &lt;!-- &lt;EmbedAllSources&gt;true&lt;&#x2F;EmbedAllSources&gt; --&gt;</span><br><span class="line">  &lt;&#x2F;PropertyGroup&gt;</span><br></pre></td></tr></table></figure><h3 id="IncludeSymbols-amp-amp-SymbolPackageFormat"><a href="#IncludeSymbols-amp-amp-SymbolPackageFormat" class="headerlink" title="IncludeSymbols &amp;&amp; SymbolPackageFormat"></a>IncludeSymbols &amp;&amp; SymbolPackageFormat</h3><p>这两个设置可以让发布nuget包带上pdb信息</p><h3 id="EmbedUntrackedSources-amp-amp-EmbedAllSources"><a href="#EmbedUntrackedSources-amp-amp-EmbedAllSources" class="headerlink" title="EmbedUntrackedSources &amp;&amp; EmbedAllSources"></a>EmbedUntrackedSources &amp;&amp; EmbedAllSources</h3><p>当EmbedAllSources设置为true的时候，会将所有源码信息内嵌到pdb文件中，后续调试的时候不需要再从git拉取。反之EmbedUntrackedSources则只会将那些没有被git管理到源码嵌入到pdb文件中</p><h3 id="PublishRepositoryUrl"><a href="#PublishRepositoryUrl" class="headerlink" title="PublishRepositoryUrl"></a>PublishRepositoryUrl</h3><p>让sourcelink可以找到相关的源码文件</p><h2 id="源码控制设置"><a href="#源码控制设置" class="headerlink" title="源码控制设置"></a>源码控制设置</h2><p>目前sourcelink支持一下集中源码管理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.SourceLink.GitHub (depends on Microsoft.Build.Tasks.Git package)</span><br><span class="line">Microsoft.SourceLink.AzureRepos.Git (depends on Microsoft.Build.Tasks.Git package)</span><br><span class="line">Microsoft.SourceLink.AzureDevOpsServer.Git (depends on Microsoft.Build.Tasks.Git package)</span><br><span class="line">Microsoft.SourceLink.GitLab (depends on Microsoft.Build.Tasks.Git package)</span><br><span class="line">Microsoft.SourceLink.Bitbucket.Git (depends on Microsoft.Build.Tasks.Git package)</span><br></pre></td></tr></table></figure><p>如过你的nuget包的源码是托管再github上，那么再项目文件中需要增加如下引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ItemGroup Label&#x3D;&quot;SourceLink&quot;&gt;</span><br><span class="line">    &lt;PackageReference Include&#x3D;&quot;Microsoft.SourceLink.GitHub&quot; Version&#x3D;&quot;1.0.0&quot; PrivateAssets&#x3D;&quot;All&quot; &gt;</span><br><span class="line">      &lt;PrivateAssets&gt;all&lt;&#x2F;PrivateAssets&gt;</span><br><span class="line">      &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers&lt;&#x2F;IncludeAssets&gt;</span><br><span class="line">    &lt;&#x2F;PackageReference&gt;</span><br><span class="line">  &lt;&#x2F;ItemGroup&gt;</span><br></pre></td></tr></table></figure><h3 id="构建并打包"><a href="#构建并打包" class="headerlink" title="构建并打包"></a>构建并打包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dotnet build -c Release</span><br><span class="line">dotnet pack -c Release</span><br></pre></td></tr></table></figure><p>安装sourcelink cli工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet tool install --global sourcelink</span><br></pre></td></tr></table></figure><p>验证相关的pdb文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sourcelink test SVNSourceLinkDemo.Common.pdb </span><br><span class="line">sourcelink test passed: SVNSourceLinkDemo.Common.pdb</span><br></pre></td></tr></table></figure><p>查看相关sourcelink信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sourcelink print-json  SVNSourceLinkDemo.Common.pdb</span><br><span class="line">&#123;&quot;documents&quot;:&#123;&quot;C:\\Development\\NetCore\\SVNSourceLinkDemo\\*&quot;:&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;LoremipsumSharp&#x2F;SVNSourceLinkDemo&#x2F;8a302ea20ba8b3d3fd81086f2f28a0c7183e185a&#x2F;*&quot;&#125;&#125;</span><br></pre></td></tr></table></figure><p>其中注意到<strong>8a302ea20ba8b3d3fd81086f2f28a0c7183e185a</strong>，这个guid是git的commit id</p><h2 id="调试配置"><a href="#调试配置" class="headerlink" title="调试配置"></a>调试配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Use IntelliSense to find out which attributes exist for C# debugging</span><br><span class="line">            &#x2F;&#x2F; Use hover for the description of the existing attributes</span><br><span class="line">            &#x2F;&#x2F; For further information visit https:&#x2F;&#x2F;github.com&#x2F;OmniSharp&#x2F;omnisharp-vscode&#x2F;blob&#x2F;master&#x2F;debugger-launchjson.md</span><br><span class="line">            &quot;name&quot;: &quot;.NET Core Launch (console)&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;coreclr&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;preLaunchTask&quot;: &quot;build&quot;,</span><br><span class="line">            &#x2F;&#x2F; If you have changed target frameworks, make sure to update the program path.</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;&#x2F;bin&#x2F;Debug&#x2F;netcoreapp2.1&#x2F;HelloWorld.dll&quot;,</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class="line">            &#x2F;&#x2F; For more information about the &#39;console&#39; field, see https:&#x2F;&#x2F;aka.ms&#x2F;VSCode-CS-LaunchJson-Console</span><br><span class="line">            &quot;console&quot;: &quot;internalConsole&quot;,</span><br><span class="line">            &quot;stopAtEntry&quot;: false,</span><br><span class="line">            &quot;justMyCode&quot;: false,</span><br><span class="line">            &quot;symbolOptions&quot;: &#123;</span><br><span class="line">                &quot;searchPaths&quot;: [],</span><br><span class="line">                &quot;searchMicrosoftSymbolServer&quot;: true,</span><br><span class="line">                &quot;searchNuGetOrgSymbolServer&quot;: true,</span><br><span class="line">                &quot;moduleFilter&quot;: &#123;</span><br><span class="line">                    &quot;mode&quot;: &quot;loadOnlyIncluded&quot;,</span><br><span class="line">                    &quot;excludedModules&quot;: [&quot;SVNSourceLinkDemo*.dll&quot;]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;.NET Core Attach&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;coreclr&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;attach&quot;,</span><br><span class="line">            &quot;processId&quot;: &quot;$&#123;command:pickProcess&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中justMyCode与symbolOptions是新增vscode调试配置</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://queil.net/blog/2019/seamless-debugging-of-nuget-packages/" target="_blank" rel="noopener">SEAMLESS DEBUGGING OF NUGET PACKAGES</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在日常开发中，我们将一些封装好的类库以nuget包的形式发布到nuget服务器上，通过引用这些nuget包来增加开发效率，减少重复代码。由于
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>使用Utf8Json改善Ocelot对象序列化的性能</title>
    <link href="https://loremipsumsharp.github.io/2021/04/07/%E4%BD%BF%E7%94%A8Utf8Json%E6%94%B9%E5%96%84Ocelot%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%80%A7%E8%83%BD/"/>
    <id>https://loremipsumsharp.github.io/2021/04/07/%E4%BD%BF%E7%94%A8Utf8Json%E6%94%B9%E5%96%84Ocelot%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%80%A7%E8%83%BD/</id>
    <published>2021-04-06T17:00:00.000Z</published>
    <updated>2021-04-06T19:34:24.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>近期在对部门的crm系统进行服务化改造，服务化改造过程中，选择了ocelot作为api网关。各个服务的response到达ocelot之后，ocelot会对response做进一步封装，形成统一的规范格式后再返回给client，eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Response</span><br><span class="line">&#123;</span><br><span class="line">    public Response(object data)</span><br><span class="line">    &#123;</span><br><span class="line">        Code &#x3D; 0;</span><br><span class="line">        Data &#x3D; data;</span><br><span class="line">        Message &#x3D; &quot;Success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public Response(string message, int code &#x3D; 500)</span><br><span class="line">    &#123;</span><br><span class="line">        Code &#x3D; code;</span><br><span class="line">        Message &#x3D; message;</span><br><span class="line">    &#125;</span><br><span class="line">    public int Code &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public string Message &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public object Data &#123; get; set; &#125; &#x2F;&#x2F; 服务端返回的数据</span><br><span class="line"></span><br><span class="line">    public bool Success &#123; get &#123; return Code &#x3D;&#x3D; 0; &#125; &#125;</span><br><span class="line"></span><br><span class="line">    public string Error &#123;get;set;&#125;</span><br></pre></td></tr></table></figure><p>通过ocelot对response格式进行统一处理，这样依赖就不需要每个服务再去单独写一个ResultFilter来处理，减少了大量重复代码。</p><p>为了实现这个功能，那么就必须在ocelot中对各个服务的response进行序列化/反序列化处理。这样势必对ocelot的性能造成一定的影响。<br>那么有没有办法优化序列化/反序列化的性能呢？</p><h2 id="Utf8Json"><a href="#Utf8Json" class="headerlink" title="Utf8Json"></a>Utf8Json</h2><p><a href="https://github.com/neuecc/Utf8Json" target="_blank" rel="noopener">Utf8Json</a> 是一个日本人写的一个Json序列化器，目前宣称是拥有最好的序列化性能。相关<a href="https://michaelscodingspot.com/the-battle-of-c-to-json-serializers-in-net-core-3/" target="_blank" rel="noopener">结论</a>也支持这一观点:</p><p><strong>For serialization, Utf8Json is 2 times faster than System.Text.Json and a whole 4 times faster than Newtonsoft. For deserialization, Utf8Json is 3.5 times faster than System.Text.Json and 6 times faster than Newtonsoft.</strong></p><p>查阅官方文档，utf8json之所以这么快主要原因有如下几个：</p><ol><li>不需要额外的内存分配<br>以Json.NET为例，如果我们希望将一个对象变成一个字节数组,待会会有以下两种方法：</li></ol><p>方法一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] SerializeJson(DrawDescriptionLayer layer)</span><br><span class="line">&#123;</span><br><span class="line">    var s &#x3D; JsonConvert.SerializeObject(layer, js);</span><br><span class="line">    return Encoding.UTF8.GetBytes(s); &#x2F;&#x2F;rent from array pool here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] SerializeJson2(DrawDescriptionLayer layer)</span><br><span class="line">&#123;</span><br><span class="line">    using (var ms &#x3D; new MemoryStream())</span><br><span class="line">    using (StreamWriter writer &#x3D; new StreamWriter(ms, Encoding.UTF8))</span><br><span class="line">    using (JsonTextWriter jsonWriter &#x3D; new JsonTextWriter(writer))</span><br><span class="line">    &#123;</span><br><span class="line">        JsonSerializer ser &#x3D; JsonSerializer.Create(js);</span><br><span class="line">        ser.Serialize(jsonWriter, layer);</span><br><span class="line">        jsonWriter.Flush();</span><br><span class="line">        return ms.ToArray(); &#x2F;&#x2F;rent from array pool here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两种方法都无一例外的产生了额外的内存分配，效率不高。以方法二为例，创建一个新的streamwriter就会导致一个bytes[3075]的allocation，很有可能我们并不需要这么多，同理UTF8.GetBytes也有这个问题。</p><p>而Utf8json则做到了按需分配，比如，当我们执行如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var bytes &#x3D; Utf8Json.JsonSerializer.Serialize(obj1, jsonresolver);</span><br></pre></td></tr></table></figure><p>utf8json首先会从内存池取出一个buffer（每个线程一个副本）来生成bytes数组的具体内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] Serialize&lt;T&gt;(T value, IJsonFormatterResolver resolver)</span><br><span class="line">        &#123;</span><br><span class="line">            if (resolver &#x3D;&#x3D; null) resolver &#x3D; DefaultResolver;</span><br><span class="line"></span><br><span class="line">            var writer &#x3D; new JsonWriter(MemoryPool.GetBuffer());</span><br><span class="line">            var formatter &#x3D; resolver.GetFormatterWithVerify&lt;T&gt;();</span><br><span class="line">            formatter.Serialize(ref writer, value, resolver);</span><br><span class="line">            return writer.ToUtf8ByteArray();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>然后将bytes数据拷贝的dst后返回给调用端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">byte[] FastCloneWithResize(byte[] src, int newSize)</span><br><span class="line">        &#123;</span><br><span class="line">            if (newSize &lt; 0) throw new ArgumentOutOfRangeException(&quot;newSize&quot;);</span><br><span class="line">            if (src.Length &lt; newSize) throw new ArgumentException(&quot;length &lt; newSize&quot;);</span><br><span class="line"></span><br><span class="line">            if (src &#x3D;&#x3D; null) return new byte[newSize];</span><br><span class="line"></span><br><span class="line">            byte[] dst &#x3D; new byte[newSize];</span><br><span class="line"></span><br><span class="line">#if NETSTANDARD &amp;&amp; !NET45</span><br><span class="line">            fixed (byte* pSrc &#x3D; &amp;src[0])</span><br><span class="line">            fixed (byte* pDst &#x3D; &amp;dst[0])</span><br><span class="line">            &#123;</span><br><span class="line">                Buffer.MemoryCopy(pSrc, pDst, dst.Length, newSize);</span><br><span class="line">            &#125;</span><br><span class="line">#else</span><br><span class="line">            Buffer.BlockCopy(src, 0, dst, 0, newSize);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">            return dst;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这样依赖内存可以复用，并且没有带来额外的损耗</p><p>2.对数值型到字符串的转化进行了特定的优化，如int-&gt;string（itoa）,double-&gt;string(google/double-conversion)</p><p>3.<a href="https://github.com/dotnet/coreclr/pull/3118" target="_blank" rel="noopener">优化了Buffer.MemoryCopy的性能问题</a></p><p>等等。</p><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>定义一个Formatter专门用于处理服务端的response：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;  Utf8Json的JRaw,压榨性能</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    public class JRawFormatter : IJsonFormatter&lt;JRaw&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        public static JRawFormatter Instance;</span><br><span class="line"></span><br><span class="line">        static JRawFormatter()</span><br><span class="line">        &#123;</span><br><span class="line">            Instance &#x3D; new JRawFormatter();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F;  没有反序列化场景，暂时不管</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;reader&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;formatterResolver&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;</span><br><span class="line">        public JRaw Deserialize(ref JsonReader reader, IJsonFormatterResolver formatterResolver)</span><br><span class="line">        &#123;</span><br><span class="line">            throw new System.NotImplementedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F;  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;writer&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;value&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;formatterResolver&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">        public void Serialize(ref JsonWriter writer, JRaw value, IJsonFormatterResolver formatterResolver)</span><br><span class="line">        &#123;</span><br><span class="line">            if (value &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                writer.WriteNull();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            writer.WriteRaw(value.Payload);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>处理服务端返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public override async Task SetResponseOnHttpContextBody(HttpContext httpContext, DownstreamResponse response)</span><br><span class="line">        &#123;</span><br><span class="line">            object body &#x3D; default;</span><br><span class="line"></span><br><span class="line">            if (response.IsEmptyResponse())</span><br><span class="line">            &#123;</span><br><span class="line">                body &#x3D; new Response(null, 0);</span><br><span class="line">                httpContext.Response.StatusCode &#x3D; (int)HttpStatusCode.OK;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                var responsePayload &#x3D; await response.Content.ReadAsStringAsync();</span><br><span class="line">                body &#x3D; new Response(new JRaw(responsePayload));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            var bodyBytes &#x3D; Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(body, _settings));</span><br><span class="line">            httpContext.Response.Headers.AddOrReplaceHeaderKey(&quot;Content-Length&quot;, bodyBytes.Length.ToString());</span><br><span class="line">            await httpContext.Response.Body.WriteAsync(bodyBytes);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/neuecc/Utf8Json" target="_blank" rel="noopener">Utf8Json</a></p><p><a href="https://michaelscodingspot.com/the-battle-of-c-to-json-serializers-in-net-core-3/" target="_blank" rel="noopener">The Battle of C# to JSON Serializers in .NET Core 3</a></p><p><a href="https://stackoverflow.com/questions/56379096/re-use-memory-from-string-to-byte-array-conversion-with-arraypool-in-c" target="_blank" rel="noopener">Re-use memory from String to byte array conversion with ArrayPool in C#?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;近期在对部门的crm系统进行服务化改造，服务化改造过程中，选择了ocelot作为api网关。各个服务的response到达ocelot之后，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Async/Await是如何导致死锁的</title>
    <link href="https://loremipsumsharp.github.io/2021/04/03/Await&amp;Await%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81%E7%9A%84/"/>
    <id>https://loremipsumsharp.github.io/2021/04/03/Await&amp;Await%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81%E7%9A%84/</id>
    <published>2021-04-03T05:40:09.000Z</published>
    <updated>2021-04-02T17:55:05.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在使用Async/Await的过程中，经常出现原因不明的死锁，感觉代码写的没啥问题，但是程序就是卡住了，为了明白这个问题，必须知道async/await的相关原理</p><h2 id="当程序遇到await关键字后会怎么处理"><a href="#当程序遇到await关键字后会怎么处理" class="headerlink" title="当程序遇到await关键字后会怎么处理"></a>当程序遇到await关键字后会怎么处理</h2><p>当程序遇到await的关键字后，会做以下事件：</p><ol><li>将await关键字后面的相关操作注册为一个回调</li><li>释放当前线程T</li><li>如果SynchronizationContext.Current不为null，那么在步骤1的回调将通过SynchronizationContext.Post去执行（最终是步骤2的线程T去执行这段代码）</li><li>如果SynchronizationContext.Current为null，那么在步骤1的回调将会通过线程池里面的线程去执行</li></ol><h3 id="为什么会产生死锁"><a href="#为什么会产生死锁" class="headerlink" title="为什么会产生死锁"></a>为什么会产生死锁</h3><p>如下图所示：<br><a href="https://imgtu.com/i/cZt6sJ" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/04/02/cZt6sJ.png" alt="cZt6sJ.png"></a></p><ol><li>在UI线程我们调用了Wait()或者.Result，这个时候UI线程会等待异步结果</li><li>I/O线程异步操作结束后，根据以上描述，I/O线程需要SynchronizationContext.Post来继续执行await后面的逻辑，谁来执行？必然是UI线程，但是UI线程仍然在等待异步的结果，这个时候I/O线程和UI线程会出现相互等待导致死锁产生</li></ol><h3 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h3><p>如下图所示：</p><p><a href="https://imgtu.com/i/cmL6oD" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/04/03/cmL6oD.md.png" alt="cmL6oD.md.png"></a></p><p>使用<code>ConfigureAwait</code>,使用ConfigureAwait，回调会通过线程池中的线程去执行，而不是SynchronizationContext关联线程(UI线程)，所以解决了这个主要矛盾，就没有死锁了</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>由于async/await的底层使用了SynchronizationContext，SynchronizationContext有多种实现（console，gui，web）。在.NET FRAMEWORK环境下进行了实验，不仅在winform，在MVC中，在异步方法中进行同步调用，也会产生死锁。<br>但是在.NET CORE中，由于取消了SynchronizationContext，在异步方法中直接进行同步调用是没有问题的，可以放心调用，但是还是不建议这样做</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://tooslowexception.com/the-danger-of-asyncawait-and-result-in-one-picture/" target="_blank" rel="noopener">The danger of async/await and .Result in one picture</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在使用Async/Await的过程中，经常出现原因不明的死锁，感觉代码写的没啥问题，但是程序就是卡住了，为了明白这个问题，必须知道async
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>使用dotnet template engine创建项目模板</title>
    <link href="https://loremipsumsharp.github.io/2021/03/01/%E4%BD%BF%E7%94%A8dotnet%20template%20engine%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF/"/>
    <id>https://loremipsumsharp.github.io/2021/03/01/%E4%BD%BF%E7%94%A8dotnet%20template%20engine%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF/</id>
    <published>2021-02-28T17:21:04.291Z</published>
    <updated>2021-02-28T17:21:58.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>dotnet sdk安装后默认配套了若干开发模板，使用dotnet new 命令可以让开发者快速通过开发模板搭建项目。这些内置的开发模板基本可以满足日常的开发需求，但是对于一些特定场景，比如开发者想在Abp的基础上快速搭建项目，那么必须利用 <a href="https://github.com/dotnet/templating" target="_blank" rel="noopener">dotnet template engine</a>    来进行模板的定制化开发</p><p>其实在dotnet core出来之前，比较流行的的代码自动生成的方式是利用Visual Studio内置的 <a href="https://docs.microsoft.com/en-us/visualstudio/modeling/code-generation-and-t4-text-templates?view=vs-2019" target="_blank" rel="noopener">T4模板引擎</a>  如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;#@ template debug&#x3D;&quot;true&quot; hostSpecific&#x3D;&quot;true&quot; #&gt;</span><br><span class="line">&lt;#@ output extension&#x3D;&quot;.cs&quot; #&gt;</span><br><span class="line">&lt;#@ Assembly Name&#x3D;&quot;System.Core&quot; #&gt;</span><br><span class="line">&lt;#@ Assembly Name&#x3D;&quot;System.Windows.Forms&quot; #&gt;</span><br><span class="line">&lt;#@ assembly name&#x3D;&quot;EnvDTE&quot; #&gt;  </span><br><span class="line">&lt;#@ import namespace&#x3D;&quot;EnvDTE&quot; #&gt;  </span><br><span class="line">&lt;#@ import namespace&#x3D;&quot;System&quot; #&gt;</span><br><span class="line">&lt;#@ import namespace&#x3D;&quot;System.IO&quot; #&gt;</span><br><span class="line">&lt;#@ import namespace&#x3D;&quot;System.Diagnostics&quot; #&gt;</span><br><span class="line">&lt;#@ import namespace&#x3D;&quot;System.Linq&quot; #&gt;</span><br><span class="line">&lt;#@ import namespace&#x3D;&quot;System.Collections&quot; #&gt;</span><br><span class="line">&lt;#@ import namespace&#x3D;&quot;System.Collections.Generic&quot; #&gt; </span><br><span class="line">&lt;#&#x2F;&#x2F;修改using #&gt;</span><br><span class="line">using AAM.ProductManagement.Core.Models.ProductManagement;</span><br><span class="line">using AAM.ProductManagement.Core.IRepository;</span><br><span class="line">using AAM.Repository.EntityFramework;</span><br><span class="line">&lt;#&#x2F;&#x2F;修改命名空间#&gt;</span><br><span class="line">namespace AAM.ProductManagement.Repository</span><br><span class="line">&#123;</span><br><span class="line">&lt;#</span><br><span class="line">   &#x2F;&#x2F; insert your template code here the template code will be syntax highlighted </span><br><span class="line">   &#x2F;&#x2F; and you will have intellisense for all namespaces in the full edition</span><br><span class="line">   string solutionsPath &#x3D; Host.ResolveAssemblyReference(&quot;$(SolutionDir)&quot;);  </span><br><span class="line">   &#x2F;&#x2F;修改此处路径即可生成实体</span><br><span class="line">   string modelDir&#x3D;solutionsPath+&quot;\\AAM.ProductManagement.Core\\Models\\ProductManagement\\&quot;;</span><br><span class="line">   string [] filesPaths&#x3D;Directory.GetFiles(modelDir,&quot;*&quot;,SearchOption.AllDirectories);</span><br><span class="line"></span><br><span class="line">    foreach (var item in filesPaths)</span><br><span class="line">    &#123;</span><br><span class="line">FileInfo file&#x3D;new FileInfo(item);</span><br><span class="line">string className&#x3D;file.Name.Replace(&quot;.cs&quot;,&quot;&quot;);</span><br><span class="line">if(className.EndsWith(&quot;Context&quot;)) continue;</span><br><span class="line">#&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public partial class &lt;#&#x3D; className #&gt;Repository: RepositoryBase&lt;&lt;#&#x3D; className #&gt;&gt;, I&lt;#&#x3D; className #&gt;Repository</span><br><span class="line">&#123;</span><br><span class="line">public &lt;#&#x3D; className #&gt;Repository(IProductManagementUnitOfWork unitOfWork):base(unitOfWork)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;#</span><br><span class="line">&#125;</span><br><span class="line">#&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个用于快速生成仓储代码的模板。模板代码看起来相当复杂，如果不熟悉T4的语法，基本上是无法看懂，并且这种模板是无法直接调试的，你压根不知道你写的有没有问题，只有把整个模板渲染出来后才再编译一下才知道有没有问题。</p><p>总结一下，2个问题：</p><ol><li>调试不方便</li><li>有一定维护成本及学习成本</li></ol><p>为了解决上述问题，dotnet template engine用了另外一种思路：</p><p><strong>模板即代码</strong></p><p>你开发的模板首先必须是一个可以编译运行的代码，其次他才是一个模板。</p><h2 id="模板配置"><a href="#模板配置" class="headerlink" title="模板配置"></a>模板配置</h2><h3 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h3><p>每一个模板项目的根目录都必须有一个.template.config目录,再这个目录下面必须有一个template.json配置问题，如下：</p><table><thead><tr><th>Member</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>$schema</code></td><td>URI</td><td>The JSON schema for the <em>template.json</em> file. Editors that support JSON schemas enable JSON-editing features when the schema is specified. For example, <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a> requires this member to enable IntelliSense. Use a value of <code>http://json.schemastore.org/template</code>.</td></tr><tr><td><code>author</code></td><td>string</td><td>The author of the template.</td></tr><tr><td><code>classifications</code></td><td>array(string)</td><td>Zero or more characteristics of the template that a user might use to find the template when searching for it. The classifications also appear in the <em>Tags</em> column when it appears in a list of templates produced by using the `dotnet new -l</td></tr><tr><td><code>identity</code></td><td>string</td><td>A unique name for this template.</td></tr><tr><td><code>name</code></td><td>string</td><td>The name for the template that users should see.</td></tr><tr><td><code>shortName</code></td><td>string</td><td>A default shorthand name for selecting the template that applies to environments where the template name is specified by the user, not selected via a GUI. For example, the short name is useful when using templates from a command prompt with CLI commands.</td></tr><tr><td><code>sourceName</code></td><td>string</td><td>The name in the source tree to replace with the name the user specifies. The template engine will look for any occurrence of the <code>sourceName</code> mentioned in the config file and replace it in file names and file contents. The value to be replaced with can be given using the <code>-n</code> or <code>--name</code> options while running a template. If no name is specified, the current directory is used.</td></tr><tr><td><code>preferNameDirectory</code></td><td>boolean</td><td>Indicates whether to create a directory for the template if name is specified but an output directory is not set (instead of creating the content directly in the current directory). The default value is false.</td></tr></tbody></table><p>这个是template.json配置中各个字段的简要说明，下面会对几个关键字段进行介绍</p><h3 id="sourceName"><a href="#sourceName" class="headerlink" title="sourceName"></a>sourceName</h3><p>如果将sourceName定义为AAA，那么在这个模板中所有以打头AAA文件名或包含AAA文本内容都会被自动替换掉，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet new -n BBB</span><br></pre></td></tr></table></figure><p>那么 AAA会被替换为BBB，相关文件也会被重命名。一般来讲，sourceName的值就是模板文件中的csproj文件名或者sln文件名</p><h3 id="preferNameDirectory"><a href="#preferNameDirectory" class="headerlink" title="preferNameDirectory"></a>preferNameDirectory</h3><p>这个值一般会配置为true，eg：如果我在CCC目录下执行dotnet new命令，相当于 dotnet new  -n CCC</p><h3 id="symbol-特殊变量替换"><a href="#symbol-特殊变量替换" class="headerlink" title="symbol 特殊变量替换"></a>symbol 特殊变量替换</h3><p>上述两点并没有彻底解决变量替换的问题，我们需要让一些我们自己定义的变量也能够被替换掉，这个时候需要使用symbol配置,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&quot;symbols&quot;: &#123;</span><br><span class="line">        &quot;protoPackage&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;parameter&quot;,</span><br><span class="line">            &quot;replaces&quot;: &quot;_ProtoPackage_&quot;,</span><br><span class="line">            &quot;datatype&quot;: &quot;text&quot;,</span><br><span class="line">            &quot;isRequired&quot;: true,</span><br><span class="line">            &quot;description&quot;: &quot;Provide the proto package name&quot;,</span><br><span class="line">            &quot;FileRename&quot;: &quot;_ProtoPackage_&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;protoService&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;parameter&quot;,</span><br><span class="line">            &quot;replaces&quot;: &quot;_ProtoService_&quot;,</span><br><span class="line">            &quot;datatype&quot;: &quot;text&quot;,</span><br><span class="line">            &quot;isRequired&quot;: true,</span><br><span class="line">            &quot;description&quot;: &quot;Provide the proto service name&quot;,</span><br><span class="line">            &quot;FileRename&quot;: &quot;_ProtoService_&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option csharp_namespace &#x3D; &quot;AAA&quot;;</span><br><span class="line"></span><br><span class="line">package _ProtoPackage_;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The service definition.</span><br><span class="line">service _ProtoService_ &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，通过定义symbol变量可以将grpc proto文件的报名和服务名替换掉</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>只用上述的三个配置参数，个人可以满足90%的场景需求，模板定制，无非就是变量替换，对于一些其他的场景微软官方也提供了相应的<a href="https://github.com/dotnet/dotnet-template-samples" target="_blank" rel="noopener">例子</a></p><h2 id="模板发布、安装、卸载"><a href="#模板发布、安装、卸载" class="headerlink" title="模板发布、安装、卸载"></a>模板发布、安装、卸载</h2><p>一般说来，模板开发完后我们会讲模板存放到内部的nuget服务器，为此，新建另外一个新的项目，来对模板文件打包，注意这里我们新建一个新的项目仅仅是为了将我们的模板内容传到nuget服务器，这个新建项目不是模板。<br>eg，项目结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">project_folder</span><br><span class="line">│   MyDotnetTemplates.csproj</span><br><span class="line">│</span><br><span class="line">└───templates</span><br><span class="line">    ├───mytemplate1</span><br><span class="line">    │   │   console.cs</span><br><span class="line">    │   │   readme.txt</span><br><span class="line">    │   │</span><br><span class="line">    │   └───.template.config</span><br><span class="line">    │           template.json</span><br><span class="line">    │</span><br><span class="line">    └───mytemplate2</span><br><span class="line">        │   otherfile.cs</span><br><span class="line">        │</span><br><span class="line">        └───.template.config</span><br><span class="line">                template.json</span><br></pre></td></tr></table></figure><p>MyDotnetTemplates.csproj内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;Project Sdk&#x3D;&quot;Microsoft.NET.Sdk&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;PropertyGroup&gt;</span><br><span class="line">    &lt;PackageType&gt;Template&lt;&#x2F;PackageType&gt;</span><br><span class="line">    &lt;PackageVersion&gt;1.0&lt;&#x2F;PackageVersion&gt;</span><br><span class="line">    &lt;PackageId&gt;AdatumCorporation.Utility.Templates&lt;&#x2F;PackageId&gt;</span><br><span class="line">    &lt;Title&gt;AdatumCorporation Templates&lt;&#x2F;Title&gt;</span><br><span class="line">    &lt;Authors&gt;Me&lt;&#x2F;Authors&gt;</span><br><span class="line">    &lt;Description&gt;Templates to use when creating an application for Adatum Corporation.&lt;&#x2F;Description&gt;</span><br><span class="line">    &lt;PackageTags&gt;dotnet-new;templates;contoso&lt;&#x2F;PackageTags&gt;</span><br><span class="line">    &lt;TargetFramework&gt;netstandard2.0&lt;&#x2F;TargetFramework&gt;</span><br><span class="line"></span><br><span class="line">    &lt;IncludeContentInPack&gt;true&lt;&#x2F;IncludeContentInPack&gt;</span><br><span class="line">    &lt;IncludeBuildOutput&gt;false&lt;&#x2F;IncludeBuildOutput&gt;</span><br><span class="line">    &lt;ContentTargetFolders&gt;content&lt;&#x2F;ContentTargetFolders&gt;</span><br><span class="line">  &lt;&#x2F;PropertyGroup&gt;</span><br><span class="line"></span><br><span class="line">  &lt;ItemGroup&gt;</span><br><span class="line">    &lt;Content Include&#x3D;&quot;templates\**\*&quot; Exclude&#x3D;&quot;templates\**\bin\**;templates\**\obj\**&quot; &#x2F;&gt;</span><br><span class="line">    &lt;Compile Remove&#x3D;&quot;**\*&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;ItemGroup&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;Project&gt;</span><br></pre></td></tr></table></figure><p>templates存发的是模板内容，用户如果执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet new -i AdatumCorporation.Utility.Template</span><br></pre></td></tr></table></figure><p>那么就会获得模板，<br>同理,通过以下命令可以删除模板内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet new -u AdatumCorporation.Utility.Template</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://devblogs.microsoft.com/dotnet/how-to-create-your-own-templates-for-dotnet-new/" target="_blank" rel="noopener">how to create your own templates for dotnet new</a></p><p><a href="https://github.com/dotnet/docs/edit/master/docs/core/tools/custom-templates.md" target="_blank" rel="noopener">custom-templates</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;dotnet sdk安装后默认配套了若干开发模板，使用dotnet new 命令可以让开发者快速通过开发模板搭建项目。这些内置的开发模板基本
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>如何Swashbuckle可以动态的增加EndPoint</title>
    <link href="https://loremipsumsharp.github.io/2020/12/23/%E5%A6%82%E4%BD%95%E8%AE%A9Swashbuckle%E5%8F%AF%E4%BB%A5%E5%8A%A8%E6%80%81%E7%9A%84%E5%A2%9E%E5%8A%A0EndPoint/"/>
    <id>https://loremipsumsharp.github.io/2020/12/23/%E5%A6%82%E4%BD%95%E8%AE%A9Swashbuckle%E5%8F%AF%E4%BB%A5%E5%8A%A8%E6%80%81%E7%9A%84%E5%A2%9E%E5%8A%A0EndPoint/</id>
    <published>2020-12-23T05:40:09.000Z</published>
    <updated>2021-11-06T19:28:46.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>不得不说<a href="https://github.com/Burgyn/MMLib.SwaggerForOcelot" target="_blank" rel="noopener">MMLib.SwaggerForOcelot</a>这个Ocelot Swagger插件是真的好用，可以很方便的集成下游服务的swagger.json到网关之中，极大的简化了客户端的调试工作。但是这个插件有一个致命的缺陷，那就是无法动态的支持下游结点。也就是说如果下游增加一个新的结点，如果你想把这个结点swagger带出来的话，那么就必须重启ocelot。<br><a href="https://github.com/domaindrivendev/Swashbuckle.AspNetCore/issues/1093" target="_blank" rel="noopener">这个issue</a>也提到了这个问题，作者大概的意思就是说，没办法实现，要改的东西太多了，那么究竟有没有办法实现这个动态加载swagger的功能呢？答案是有</p><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>先回忆一下我们平时我们集成swagger的常见写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void ConfigureServices(IServiceCollection services)</span><br><span class="line">&#123;</span><br><span class="line">     services.AddSwaggerGen(c &#x3D;&gt; .....);</span><br><span class="line">&#125;</span><br><span class="line"> public void Configure(IApplicationBuilder app, IWebHostEnvironment env)</span><br><span class="line"> &#123;</span><br><span class="line">       app.UseSwagger();</span><br><span class="line">       app.UseSwaggerUI(options &#x3D;&gt;</span><br><span class="line">       &#123;</span><br><span class="line">          options.SwaggerEndpoint(&quot;&#x2F;swagger&#x2F;v1&#x2F;swagger.json&quot;, &quot;XXX API V1&quot;);</span><br><span class="line">       &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>翻一下Swashbuckle的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static IApplicationBuilder UseSwaggerUI(</span><br><span class="line">         this IApplicationBuilder app,</span><br><span class="line">         Action&lt;SwaggerUIOptions&gt; setupAction &#x3D; null)</span><br><span class="line">     &#123;</span><br><span class="line">         var options &#x3D; new SwaggerUIOptions();</span><br><span class="line">         if (setupAction !&#x3D; null)</span><br><span class="line">         &#123;</span><br><span class="line">             setupAction(options);</span><br><span class="line">         &#125;</span><br><span class="line">         else</span><br><span class="line">         &#123;</span><br><span class="line">             options &#x3D; app.ApplicationServices.GetRequiredService&lt;IOptions&lt;SwaggerUIOptions&gt;&gt;().Value;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         app.UseMiddleware&lt;SwaggerUIMiddleware&gt;(options);</span><br><span class="line"></span><br><span class="line">         return app;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>注意到 SwaggerUIMiddleware的构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class SwaggerUIMiddleware</span><br><span class="line">      public SwaggerUIMiddleware(</span><br><span class="line">          RequestDelegate next,</span><br><span class="line">          IHostingEnvironment hostingEnv,</span><br><span class="line">          ILoggerFactory loggerFactory,</span><br><span class="line">          SwaggerUIOptions options)</span><br><span class="line">      &#123;</span><br><span class="line">          _options &#x3D; options ?? new SwaggerUIOptions();</span><br><span class="line"></span><br><span class="line">          _staticFileMiddleware &#x3D; CreateStaticFileMiddleware(next, hostingEnv, loggerFactory, options);</span><br><span class="line"></span><br><span class="line">          _jsonSerializerOptions &#x3D; new JsonSerializerOptions();</span><br><span class="line">          _jsonSerializerOptions.PropertyNamingPolicy &#x3D; JsonNamingPolicy.CamelCase;</span><br><span class="line">          _jsonSerializerOptions.IgnoreNullValues &#x3D; true;</span><br><span class="line">          _jsonSerializerOptions.Converters.Add(new JsonStringEnumConverter(JsonNamingPolicy.CamelCase, false));</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>那么无法使用dynamic endpoint的原因很明显，因为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.UseMiddleware&lt;SwaggerUIMiddleware&gt;(options);</span><br></pre></td></tr></table></figure><p>上面这句话本质上是把这个SwaggerUIMiddleware注册成一个单例，也就是说他的构造函数只会执行一次。那么你后续取到的endpoint必然就是一个“静态”的东西，那么解决这个主要矛盾就行了</p><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>这里只是阐述思路，具体的实践方法可以自己去尝试：</p><p>首先我们通过一个scope configurer，每一个http请求都会触发swaggeruioptions的重新config</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddScoped&lt;IConfigureOptions&lt;SwaggerUIOptions&gt;, SwaggerUIOptionsConfigure&gt;();</span><br></pre></td></tr></table></figure><p>这样一来可以让SwaggerUIOptions动态的变化</p><p>然后，我们必须把SwaggerUIMiddleware替换掉，也就是说，我们没必要这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.UseSwagger();</span><br><span class="line">          app.UseSwaggerUI(options &#x3D;&gt;</span><br><span class="line">          &#123;</span><br><span class="line">             options.SwaggerEndpoint(&quot;&#x2F;swagger&#x2F;v1&#x2F;swagger.json&quot;, &quot;XXX API V1&quot;);</span><br><span class="line">          &#125;);</span><br></pre></td></tr></table></figure><p>我们可以开发一个新的中间件来替换掉把SwaggerUIMiddleware，eg:RenderSwaggerUI</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> public class RenderSwaggerUI : IMiddleware</span><br><span class="line"> &#123;</span><br><span class="line">   public RenderSwaggerUI(IWebHostEnvironment hostingEnv,</span><br><span class="line">            ILoggerFactory loggerFactory,</span><br><span class="line">            IOptionsSnapshot&lt;SwaggerUIOptions&gt; swaggerUIOptions,</span><br><span class="line">            IOptionsSnapshot&lt;List&lt;RouteOptions&gt;&gt; routes,</span><br><span class="line">            IOptionsSnapshot&lt;SwaggerForOcelotUIOptions&gt; swaggerForOcelotUIOptions,</span><br><span class="line">            IOptionsSnapshot&lt;List&lt;SwaggerEndPointOptions&gt;&gt; swaggerEndPoints,</span><br><span class="line">            IHttpClientFactory httpClientFactory,</span><br><span class="line">            ISwaggerJsonTransformer swaggerJsonTransformer, ISwaggerServiceDiscoveryProvider swaggerServiceDiscoveryProvider)</span><br><span class="line">        &#123;</span><br><span class="line">            this.hostingEnv &#x3D; hostingEnv;</span><br><span class="line">            this.loggerFactory &#x3D; loggerFactory;</span><br><span class="line">            this.swaggerUIOptions &#x3D; swaggerUIOptions.Value;</span><br><span class="line">            this.swaggerForOcelotUIOptions &#x3D; swaggerForOcelotUIOptions.Value;</span><br><span class="line">            this.httpClientFactory &#x3D; httpClientFactory;</span><br><span class="line">            this.swaggerJsonTransformer &#x3D; swaggerJsonTransformer;</span><br><span class="line">            this.swaggerEndPoints &#x3D; swaggerEndPoints.Value;</span><br><span class="line">            this.routes &#x3D; routes.Value;</span><br><span class="line">            this.swaggerServiceDiscoveryProvider &#x3D; swaggerServiceDiscoveryProvider;</span><br><span class="line">        &#125;</span><br><span class="line">    public async Task InvokeAsync(HttpContext context, RequestDelegate next)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">            var swaggerUIMiddleware &#x3D; new SwaggerUIMiddleware(next, this.hostingEnv, this.loggerFactory, this.swaggerUIOptions);</span><br><span class="line">            await swaggerUIMiddleware.Invoke(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这里RenderSwaggerUI实现IMiddleware，目的是让这个中间件被自动注册成一个scope中间件，每次都会执行构造函数.然后手动 new 一个 swaggerUIMiddleware并Invoke</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Swashbuckle的dynamic endpoint是可以实现的，只不过比较绕，这种方法不是最优解，但是可以解决问题。期待后续作者解决这个问题。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-5.0" target="_blank" rel="noopener">Dependency injection in ASP.NET Core</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h2&gt;&lt;p&gt;不得不说&lt;a href=&quot;https://github.com/Burgyn/MMLib.SwaggerForOcelot&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>rxjs中tap,map,switchmap的区别</title>
    <link href="https://loremipsumsharp.github.io/2020/10/26/rxjs%E4%B8%ADtap,map,switchmap%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://loremipsumsharp.github.io/2020/10/26/rxjs%E4%B8%ADtap,map,switchmap%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-10-25T17:52:23.830Z</published>
    <updated>2020-10-25T19:35:42.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前端三大框架angular,react,vue中，angular是唯一一个对rxjs进行了深度集成的框架。rxjs通过大量内置operator，极大的简化了前端对事件流的处理。</p><p>对于一个.NET后端开发来说，上手rxjs不算难事，rxjs的operator都能在Linq上面找到对应的原型，<br>所以说对于有志于成为全栈的.NET开发，angular是一个不错的选择。</p><p>在angular开发过程中，tap,map,switchmap（经常被用来做限流）这三个operator的出场率很高，但由于这三个operator的命名很相似，经常容易搞混。这里简单介绍下这三个operator的区别</p><h3 id="tap"><a href="#tap" class="headerlink" title="tap"></a>tap</h3><p>tap，并不会返回一个新的observable，只是对observable的stream进行预处理，如在调试过程中，我们经常会用tap把stream中的元素先打印出来，观测处理前和处理后的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; from &#125; from &quot;rxjs&quot;;</span><br><span class="line">import &#123; tap &#125; from &quot;rxjs&#x2F;operators&quot;;</span><br><span class="line"></span><br><span class="line">from([1, 2, 3])</span><br><span class="line">  .pipe(tap(item &#x3D;&gt;  &#x2F;* do something *&#x2F;))</span><br><span class="line">  .subscribe(item &#x3D;&gt; console.log(item));</span><br></pre></td></tr></table></figure><p>tap类似于Rx.NET中的do operator</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map，对input stream进行处理，并返回一个新的observable</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; from &#125; from &#39;rxjs&#39;;</span><br><span class="line">import &#123; map &#125; from &#39;rxjs&#x2F;operators&#39;;</span><br><span class="line"></span><br><span class="line">from([1, 2, 3])</span><br><span class="line">  .pipe(map((item) &#x3D;&gt; item + 2))</span><br><span class="line">  .subscribe((item) &#x3D;&gt; console.log(item));</span><br></pre></td></tr></table></figure><p>map类似于Rx.NET中的select operator</p><h3 id="switchMap"><a href="#switchMap" class="headerlink" title="switchMap"></a>switchMap</h3><p>将一个内嵌的observable做flatten处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; from &#125; from &#39;rxjs&#39;;</span><br><span class="line">import &#123; map &#125; from &#39;rxjs&#x2F;operators&#39;;</span><br><span class="line"></span><br><span class="line">from([1, 2, 3])</span><br><span class="line">  observable as return value.</span><br><span class="line"> itself is a new observable now,</span><br><span class="line">  .pipe(map((item) &#x3D;&gt; methodWhichReturnsObservable(item)))</span><br><span class="line">  .subscribe((item) &#x3D;&gt; console.log(item));</span><br></pre></td></tr></table></figure><p>在上述代码中如果methodWhichReturnsObservable也是返回一个observable，那么console.log(item) 打印出来的item并不是一个number，而是一个observable。</p><p>为了处理这一种情况，只需将map改成switchmap</p><p>switchmap类似于Rx.NET中的selectmany</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; from &#125; from &quot;rxjs&quot;;</span><br><span class="line">import &#123; switchMap &#125; from &quot;rxjs&#x2F;operators&quot;;</span><br><span class="line"></span><br><span class="line">from([1, 2, 3])</span><br><span class="line">  .pipe(switchMap(item &#x3D;&gt; methodWhichReturnsObservable(item))</span><br><span class="line">  .subscribe(resultItem &#x3D;&gt; console.log(resultItem));</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://reactivex.io/documentation/operators.html" target="_blank" rel="noopener">Rx Operators</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在前端三大框架angular,react,vue中，angular是唯一一个对rxjs进行了深度集成的框架。rxjs通过大量内置operat
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Grpc Channel没有关闭而导致的内存泄露问题排查</title>
    <link href="https://loremipsumsharp.github.io/2020/09/22/GrpcChannel%E6%B2%A1%E6%9C%89%E6%AD%A3%E5%B8%B8%E5%85%B3%E9%97%AD%E8%80%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>https://loremipsumsharp.github.io/2020/09/22/GrpcChannel%E6%B2%A1%E6%9C%89%E6%AD%A3%E5%B8%B8%E5%85%B3%E9%97%AD%E8%80%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</id>
    <published>2020-09-22T00:23:22.413Z</published>
    <updated>2021-04-02T16:50:49.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>日前上线了一个用于统计统计用户活跃度的服务，上线之后，出现了内存泄漏的问题，通过lldb对程序的core dump进行分析，最终找到了泄漏的原因</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>服务上线后，出现大量告警，提示服务器内存不足，grafana监控提示服务内存泄漏：</p><p><img src="https://raw.githubusercontent.com/LoremipsumSharp/Images/master/img/WeChat%20Screenshot_20200922084321.png" alt=""></p><p>使用将线上的服务的内存dump下来，继续观察：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;2.1.1&#x2F;createdump -u 1</span><br></pre></td></tr></table></figure><p>通过lldb加载core dump文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lldb-3.9 dotnet -c &#x2F;tmp&#x2F;20290824_activevalue_coredump  -o &quot;plugin load &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;2.1.1&#x2F;libsosplugin.so&quot;</span><br></pre></td></tr></table></figure><p>查看堆大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eeheap -gc</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/LoremipsumSharp/Images/master/img/WeChat%20Screenshot_20200927023535.png" alt=""></p><p>进一步查看当前堆各个类型的对象数量<br><code>dumpheap -stat</code></p><p>提示有大量Grpc对象积压.</p><p>进一步，对项目的各个接口进行压测,对内存进行三次采样：</p><p>第一次采样77MB:</p><p><img src="https://raw.githubusercontent.com/LoremipsumSharp/Images/master/img/dasdasdas.png" alt=""></p><p>第二次采样82MB:</p><p><img src="https://raw.githubusercontent.com/LoremipsumSharp/Images/master/img/2323fadas.png" alt=""></p><p>第三次采样 86MB：</p><p><img src="https://raw.githubusercontent.com/LoremipsumSharp/Images/master/img/adasdasgdfasdas.png" alt=""></p><p>VS内存分析工具提示GRPC内存对象一直没有得到有效的控制，数量不断上升<br>在采样过程中手动进行GC，只是下降53个对象，大量channel仍然驻留内存:</p><p><img src="https://raw.githubusercontent.com/LoremipsumSharp/Images/master/img/dasdasfdvfsdvsdf.png" alt=""></p><p><img src="https://raw.githubusercontent.com/LoremipsumSharp/Images/master/img/dasdascas.png" alt=""></p><p>根据上述采样分析，可以肯定业务代码中存在grpc channel正常关闭的场景。</p><p>进一步查看代码发现：<br><img src="https://raw.githubusercontent.com/LoremipsumSharp/Images/master/img/WeChat%20Screenshot_20200927024147.png" alt=""></p><p>每一次通过grpc client调用其他服务的时候会直接常见Channel，而不是复用之前的Channel，并且创建后的Channel没有关闭</p><p>修复这部分代码后，线上内存使用率恢复正常</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/grpc/grpc-java/issues/3268" target="_blank" rel="noopener">Channel creation best practice</a></p><p><a href="https://docs.microsoft.com/zh-cn/aspnet/core/grpc/performance?view=aspnetcore-5.0" target="_blank" rel="noopener">Performance best practices with gRPC</a>！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;日前上线了一个用于统计统计用户活跃度的服务，上线之后，出现了内存泄漏的问题，通过lldb对程序的core dump进行分析，最终找到了泄漏的
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Union查询性能优</title>
    <link href="https://loremipsumsharp.github.io/2020/09/21/Union%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98/"/>
    <id>https://loremipsumsharp.github.io/2020/09/21/Union%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98/</id>
    <published>2020-09-20T18:58:22.193Z</published>
    <updated>2020-09-20T19:27:56.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Union的工作原理"><a href="#Union的工作原理" class="headerlink" title="Union的工作原理"></a>Union的工作原理</h2><p>假设现在有两个集合A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blue</span><br><span class="line">green</span><br><span class="line">gray</span><br><span class="line">black</span><br></pre></td></tr></table></figure><p>集合B：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">red</span><br><span class="line">green</span><br><span class="line">yellow</span><br><span class="line">blue</span><br></pre></td></tr></table></figure><p>现在对集合A、B进行Union操作，首先Mysql会创建一个临时表来暂存A ∪ B = C<br>Step1(将A的元素和B的元素都添加到C中)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">black</span><br><span class="line">blue</span><br><span class="line">blue</span><br><span class="line">gray</span><br><span class="line">green</span><br><span class="line">green</span><br><span class="line">red</span><br><span class="line">yellow</span><br></pre></td></tr></table></figure><p>接下来对C进行去重，得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">black</span><br><span class="line">blue</span><br><span class="line">gray</span><br><span class="line">green</span><br><span class="line">red</span><br><span class="line">yellow</span><br></pre></td></tr></table></figure><h2 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h2><h3 id="使用Union-All"><a href="#使用Union-All" class="headerlink" title="使用Union All"></a>使用Union All</h3><p>对一个大数据集进行去重操作需要很高的算力，当业务场景可以接收重复结果的情况下，使用Union All，Union All不会对结果集进行去重，这个时候可以减少Union去重带来的性能损耗</p><h3 id="将查询条件放在Union的子查询中"><a href="#将查询条件放在Union的子查询中" class="headerlink" title="将查询条件放在Union的子查询中"></a>将查询条件放在Union的子查询中</h3><p>如果不将查询条件放在子查询之中，这个时候默认Union将各个子查询的结果全部查出来，然后放到一个临时表中，再对临时表进行过滤，这个时候，没办法利用到Mysql的索引，不利于性能的提高。所以使用Union操作的时候要尽量将查询条件，排序条件放在子查询之中。<br>另外需要注意的一点是，如果直接对子查询进行Order By操作，Mysql会提示<code>Incorrect usage of UNION and ORDER BY</code>,如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE username LIKE &#39;l%&#39; ORDER BY score ASC</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM t1 WHERE username LIKE &#39;%m%&#39; ORDER BY score ASC</span><br></pre></td></tr></table></figure><p>解决的办法就是用一个括号将子查询包起来，再进行Union操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(SELECT * FROM t1 WHERE username LIKE &#39;l%&#39; ORDER BY sroce ASC)</span><br><span class="line">UNION</span><br><span class="line">(SELECT * FROM t1 WHERE username LIKE &#39;%m%&#39; ORDER BY score ASC)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jb51.net/article/99842.htm" target="_blank" rel="noopener">MySQL中union和order by同时使用的实现方法</a></p><p><a href="https://www.iheavy.com/2013/06/13/how-to-optimize-mysql-union-for-high-speed/" target="_blank" rel="noopener">How to Optimize MySQL UNION For High Speed</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Union的工作原理&quot;&gt;&lt;a href=&quot;#Union的工作原理&quot; class=&quot;headerlink&quot; title=&quot;Union的工作原理&quot;&gt;&lt;/a&gt;Union的工作原理&lt;/h2&gt;&lt;p&gt;假设现在有两个集合A：&lt;/p&gt;
&lt;figure class=&quot;highlig
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ThreadLocal的应用</title>
    <link href="https://loremipsumsharp.github.io/2020/09/14/ThreadLocal%E5%9C%A8RabbitMq%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://loremipsumsharp.github.io/2020/09/14/ThreadLocal%E5%9C%A8RabbitMq%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2020-09-13T16:29:00.493Z</published>
    <updated>2020-09-13T17:29:49.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Thread-Local-Storage"><a href="#Thread-Local-Storage" class="headerlink" title="Thread-Local Storage"></a>Thread-Local Storage</h3><p>在日常开发过程中，你有时候可能会希望一些对象，变量可以做到线程隔离，不相互影响。为了实现这个需求，.NET引入了一个被称为<code>Thread-Local Storage</code> 的概念，通过<code>Thread-Local Storage</code>，变量、对象无需重复定义，也不需要添加锁，就可以实现在线程之间的相互隔离</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal<T></h3><p><code>ThreadLocal</code> 是 <code>Thread-Local Storage</code>的一个具体实现，一个<code>ThreadLocal</code>的对象字段，在不通线程之中可以做到相互隔离</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; contruct on this thread</span><br><span class="line">            ThreadLocalDemo demoObject &#x3D; new ThreadLocalDemo();</span><br><span class="line">            demoObject.PrintCounterValue();</span><br><span class="line">            demoObject.IncrementCounter();</span><br><span class="line">            demoObject.PrintCounterValue();</span><br><span class="line"></span><br><span class="line">          </span><br><span class="line">            var resetEvent &#x3D; new ManualResetEvent(false);</span><br><span class="line">            ThreadPool.QueueUserWorkItem(state &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">             </span><br><span class="line">                ((ThreadLocalDemo)state).PrintCounterValue();</span><br><span class="line">                ((ThreadLocalDemo)state).IncrementCounter();</span><br><span class="line">                ((ThreadLocalDemo)state).PrintCounterValue();</span><br><span class="line"></span><br><span class="line">              </span><br><span class="line">                var demo &#x3D; new ThreadLocalDemo();</span><br><span class="line">                demo.IncrementCounter();</span><br><span class="line">                demo.PrintCounterValue();</span><br><span class="line"></span><br><span class="line">                resetEvent.Set();</span><br><span class="line">            &#125;, demoObject);</span><br><span class="line"></span><br><span class="line">            resetEvent.WaitOne();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class ThreadLocalDemo</span><br><span class="line">    &#123;</span><br><span class="line">        private ThreadLocal&lt;int&gt; counter;</span><br><span class="line">        private static ThreadLocal&lt;int&gt; staticCounter;</span><br><span class="line">        private static Guid staticId;</span><br><span class="line">        private Guid id;</span><br><span class="line"></span><br><span class="line">        static ThreadLocalDemo()</span><br><span class="line">        &#123;</span><br><span class="line">            staticCounter &#x3D; new ThreadLocal&lt;int&gt;();</span><br><span class="line">            staticId &#x3D; Guid.NewGuid();</span><br><span class="line">            Console.WriteLine($&quot;Static constructor:&quot;);</span><br><span class="line">            Console.WriteLine($&quot;thread id: &#123;Thread.CurrentThread.ManagedThreadId&#125;, type id: &#123;staticId&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public ThreadLocalDemo()</span><br><span class="line">        &#123;</span><br><span class="line">            counter &#x3D; new ThreadLocal&lt;int&gt;();</span><br><span class="line">            id &#x3D; Guid.NewGuid();</span><br><span class="line">            Console.WriteLine($&quot;Constructor: thread id: &#123;Thread.CurrentThread.ManagedThreadId&#125;, object id &#123;id&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void IncrementCounter()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Incrementing both local and static counters&quot;);</span><br><span class="line">            counter.Value++;</span><br><span class="line">            staticCounter.Value++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void PrintCounterValue()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Printing current values&quot;);</span><br><span class="line">            Console.WriteLine($&quot;thread id: &#123;Thread.CurrentThread.ManagedThreadId&#125;, object id &#123;id&#125;, counter: &#123;counter.Value&#125;, static Counter: &#123;staticCounter.Value&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Static constructor:</span><br><span class="line">thread id: 1, type id: 220a1d54-0d32-4961-9f19-9da5a625eaeb</span><br><span class="line">Constructor: thread id: 1, object id a655a69c-4c16-4a6e-88b3-c339f247d895</span><br><span class="line">Printing current values</span><br><span class="line">thread id: 1, object id a655a69c-4c16-4a6e-88b3-c339f247d895, counter: 0, static Counter: 0</span><br><span class="line">Incrementing both local and static counters</span><br><span class="line">Printing current values</span><br><span class="line">thread id: 1, object id a655a69c-4c16-4a6e-88b3-c339f247d895, counter: 1, static Counter: 1</span><br><span class="line">Printing current values</span><br><span class="line">thread id: 4, object id a655a69c-4c16-4a6e-88b3-c339f247d895, counter: 0, static Counter: 0</span><br><span class="line">Incrementing both local and static counters</span><br><span class="line">Printing current values</span><br><span class="line">thread id: 4, object id a655a69c-4c16-4a6e-88b3-c339f247d895, counter: 1, static Counter: 1</span><br><span class="line">Constructor: thread id: 4, object id 3175a74e-255c-4934-ae9f-e9790d05e486</span><br><span class="line">Incrementing both local and static counters</span><br><span class="line">Printing current values</span><br><span class="line">thread id: 4, object id 3175a74e-255c-4934-ae9f-e9790d05e486, counter: 1, static Counter: 2</span><br></pre></td></tr></table></figure><p>上述代码，所在demoObj的实例计数器在Thread 1 为 1，但当进入到Thread 4 的时候，实例计数器被重置为0，也就是说<code>counter</code>的值受线程影响，不同的线程有不同的拷贝</p><h2 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h2><p><code>ThreadLocal</code>目前在自己维护的项目中应用的比较少，大多数情况会选择在线程上下文中定义一个新的变量，而不是去引用外部的<code>ThreadLocal</code>变量，目前唯一用到的就是在RabbitMQ。</p><p>根据RabbitMQ的官方文档，IModel对象不是一个线程安全的对象，每一个每一个线程应该有且只有一个IModel,建多了也没意义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Don’t share channels between threads</span><br><span class="line">Use one channel per thread in your application, and make sure that you don’t share channels between threads as most clients don’t make channels thread-safe.</span><br><span class="line"></span><br><span class="line">CloudAMQP allows you to scale your instances to meet demand while providing mechanisms to troubleshoot leaks. If you have any questions, you can reach out to us at support@cloudamqp.com</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public interface IMessagePublisher</span><br><span class="line">  &#123;</span><br><span class="line">      Task PublishAsync&lt;TMessage&gt;(TMessage message);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public class MessagePublisher : IMessagePublisher</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">      private readonly ISerializer _serializer;</span><br><span class="line">      public MessagePublisher(ISerializer serializer, IConnectionFactory connectionFactory)</span><br><span class="line">      &#123;</span><br><span class="line">          _serializer &#x3D; serializer;</span><br><span class="line">          _channel &#x3D; new ThreadLocal&lt;IModel&gt;(() &#x3D;&gt; connectionFactory.CreateConnection().CreateModel());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public async Task PublishAsync&lt;TMessage&gt;(TMessage message)</span><br><span class="line">      &#123;</span><br><span class="line">          var type &#x3D; typeof(TMessage);</span><br><span class="line">          var exchangeName &#x3D; GetExchangeName(type);</span><br><span class="line">          var routingKey &#x3D; GetRoutingKey(type);</span><br><span class="line">          var data &#x3D; _serializer.Serialize(message);</span><br><span class="line"></span><br><span class="line">          await PublishAsync(exchangeName, routingKey, data);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   services.AddSingleton&lt;IMessagePublisher, MessagePublisher&gt;();</span><br></pre></td></tr></table></figure><p>通过上述代码，虽然IMessagePublisher是单例，但channel也可以实现做到每一个线程唯一，最大程度的减少了对象的创建</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cloudamqp.com/blog/2019-11-13-the-relationship-between-connections-and-channels-in-rabbitmq.html" target="_blank" rel="noopener">What is the relationship between connections and channels in RabbitMQ?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;h3 id=&quot;Thread-Local-Storage&quot;&gt;&lt;a href=&quot;#Thread-Local-Storage&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
